<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>AAX SDK: TI Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="aaxdoxy.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cw_105x65_aax_buf.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AAX SDK
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
   <div id="projectbrief">Avid Audio Extensions Development Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Welcome</span></a></li>
      <li><a href="modules.html"><span>Manual</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Lists</span></a></li>
      <li><a href="usergroup0.html"><span>Support</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TI Guide<div class="ingroups"><a class="el" href="a00323.html">AAX SDK Manual</a> &raquo; <a class="el" href="a00359.html">AAX Host Guides</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>How to write AAX plug-ins for Avid's TI-based platforms. </p>
<h1><a class="anchor" id="aax_ti_guide_contents"></a>
Contents</h1>
<ul>
<li><a class="el" href="a00362.html#aax_ti_guide_00_overview_of_ti_algorithms">Overview of TI Algorithms in AAX</a> </li>
<li><a class="el" href="a00362.html#aax_ti_guide_01_the_hdx_platform">The HDX Platform</a> </li>
<li><a class="el" href="a00362.html#aax_ti_guide_03_requirements_for_ti_plug_ins">Requirements for TI Plug-Ins</a> </li>
<li><a class="el" href="a00362.html#aax_ti_guide_04_ti_development_tools">TI Development Tools</a> </li>
<li><a class="el" href="a00362.html#aax_ti_guide_05_common_issues_with_ti_development">Common Issues with TI Development</a> </li>
<li><a class="el" href="a00362.html#aax_ti_guide_06_ti_optimization_guide">TI Optimization Guide</a> </li>
<li><a class="el" href="a00362.html#aax_ti_guide_07_error_codes">Error Codes</a></li>
</ul>
<div class="section"> </div><h1><a class="anchor" id="aax_ti_guide_00_overview_of_ti_algorithms"></a>
Overview of TI Algorithms in AAX</h1>
<div class="section">Avid's hardware-accelerated audio systems allow AAX plug-ins to offload their real-time processing tasks to a dedicated processor, guaranteeing reliable performance at ultra-low latency. Avid's TI-based products utilize Texas Instruments DSP chips to host plug-ins in a managed shell environment.</div><div class="section">The AAX host handles all system-level communications and resources on the DSP and provides a consistent API to manage communication between the plug-in's real-time algorithm and its other components. This design allows AAX plug-ins to use the same communication methods whether they are running natively, on a TI-based accelerated system, or in some other distributed environment.</div><div class="section">Each AAX plug-in contains a real-time algorithm callback. For TI DSP-based platforms, this callback is compiled into a relocatable ELF DLL. This library is loaded onto the appropriate DSP by the host, and may share the DSP with other plug-ins if the host determines that the required system resources are available. </div><div class="section"> </div><h1><a class="anchor" id="aax_ti_guide_01_the_hdx_platform"></a>
The HDX Platform</h1>
<div class="section">HDX is Avid's PCI-based core mixer and plug-in accelerator platform. Each HDX card includes 18 TI C6727 DSPs, each clocked at 350 MHz. These DSPs utilize a 32-bit floating-point architecture, with the option to perform 64-bit double-precision operations at some performance cost.</div><div class="section"></div><h2><a class="anchor" id="subsection__dsp_characteristics_instruction_processing"></a>
DSP characteristics: instruction processing</h2>
<div class="section"> The C6727 DSP utilizes a VLIW architecture and contains dual data paths. Each data path includes four independent functional units, so the DSP can accommodate up to 8 parallel instructions per cycle. To take advantage of this architecture, the TI compiler relies heavily on instruction pipelining for optimization.</div><div class="section">In order to realize the maximum possible performance benefit from this architecture, HDX uses a four-sample processing quantum. Plug-ins that require additional processing time per callback, e.g. to mitigate the overhead cost of the chip's DMA facilities, may optionally request a 16, 32, or 64-sample quantum. But please note that at higher block sizes, the number of potential I/O channels available to plug-ins on a chip will be reduced. By guaranteeing that each algorithm will be called with a consistent buffer size, the TI compiler is able to properly account for any possible iterative instruction pipelining, resulting in large performance gains.</div><div class="section"><dl class="compatibility_notes"><dt><b><a class="el" href="a00380.html#_compatibility_notes000020">Host Compatibility Notes:</a></b></dt><dd>32 and 64-sample quantum is available in Pro Tools 10.2 and higher</dd></dl>
</div><div class="section"></div><h2><a class="anchor" id="subsection__dsp_characteristics_memory"></a>
DSP characteristics: memory</h2>
<div class="section"> Each DSP on the HDX platform includes 16 MB of external RAM and 256 kB of internal RAM. The DSP has the ability to execute code from either internal or external RAM, though the real-time performance cost of external RAM accesses is significant. The chip's internal RAM is addressable at the core clock rate.</div><div class="section">Each DSP also has a program cache of 32 kB. Plug-in code is loaded into this cache from internal memory, so for best performance your plug-in should not use more than 32 kB for its program code. You can look at the CCS-generated .map file to find your plug-in's program code size.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__sdram_performance_"></a>
SDRAM performance</h3>
<div class="section"> Asynchronous access to data in the C6727's SDRAM is very slow, requiring 50 cycles/word to read and 15 cycles/word to write. This is primarily due to clock domain bridging, lack of data caching, and the fact that data from the core is given a low priority in order to avoid stalling real-time DMA transfers. </div><h3><a class="anchor" id="subsubsection__executing_program_code_from_external_memory_"></a>
Executing program code from external memory</h3>
<div class="section"> The TI C6727 supports executing program code from external memory. When executing from uncached external memory, expect cycle counts to increase by a factor of 4x to 5x compared with the equivalent internal-memory code. Assuming that no cache thrashing occurs, subsequent calls will be cached and thus the program's location in either external or internal memory will produce similar cycle counts.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>The CCSv4 Profiler contains a bug that produces incorrect cycle counts for cached external-memory program code. Therefore, when gathering cycle count data for a plug-in that stores its program data in external memory, an RTI-based timing method should be used.</dd></dl>
</div><h2><a class="anchor" id="subsection__system_characteristics_dsphost_data_transfers"></a>
System characteristics: DSP/host data transfers</h2>
<div class="section"> Plug-ins loaded onto the HDX platform may transfer arbitrarily large data blocks between the DSP and the host, within the limits of available DSP memory and system bandwidth.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__dsphost_bandwidth_"></a>
DSP/host bandwidth</h3>
<div class="section"> The recommended upper limit for DSP/host data transfer requests in an individual plug-in is 10 MB/s, divided by the maximum number of plug-in instances that will run on a single chip. On the HDX card, DSPs are wired to the FPGA crossbar in groups of three, with a data bandwidth of approximately 67 MB/s for each group. The overall system bandwidth for each DSP is therefore approximately 20 MB/s. This bandwidth is shared by all data reads and writes, including custom data transfer requests.</div><div class="section">HDX does not include any explicit plug-in bandwidth limiting constraints. If a plug-in's data transfer requests bump up against the physical bandwidth limit for the system then this will delay the blocking data transfer request on the host, as the transfer will be held off for higher-priority operations on the DSP, and may also delay automation data from reaching other plug-ins on the three affected DSPs.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__dsphost_data_transfer_characteristics_"></a>
DSP/host data transfer characteristics</h3>
<div class="section"> The minimum data transfer size for all host-to-DSP communications in HDX is 128 bytes. This limit applies to all host-to-DSP data transfers, including data sent to buffered ports, unbuffered ports, and private data blocks (via the AAX Direct Data interface.)</div><div class="section">Since each transfer has a minimum size of 128 bytes, the use of many small packets does not increase transfer efficiency or save system bandwidth. Quite the opposite: updating a single 64-byte packet would require less bandwidth than updating two 4-byte packets in an HDX system, since the former would require only one 128-byte transfer while the latter will require two.</div><div class="section"></div><h2><a class="anchor" id="subsection__ti_shell_characteristics_memory_allocation"></a>
TI Shell characteristics: Memory allocation</h2>
<div class="section"> </div><h3><a class="anchor" id="subsubsection__memory_resource_availability_"></a>
Memory resource availability</h3>
<div class="section"> The TI Shell code that is loaded onto each DSP uses approximately 56 kB of internal memory, leaving 200 kB of internal memory per DSP. This memory is shared between the plug-ins on the chip and holds the plug-ins' code and data, per-instance blocks declared in Describe(), and instance overhead.</div><div class="section">As a general guideline, plug-in instances should not use more than 200 / n kB of internal memory, where n is the number of instances of your plug-in that will run on a single chip based on its cycle count requirements.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__shared_and_perinstance_memory_allocation_"></a>
Shared and per-instance memory allocation</h3>
<div class="section"> When a plug-in instance is created on a DSP, its program code is loaded onto that DSP. This copy of the program code is then re-used for all subsequent instances of the effect that are loaded onto the DSP. Static and global data are also shared between all instances of an effect on the DSP. Other allocations, such as coefficient and private data blocks, are per-instance.</div><div class="section"><dl class="compatibility_notes"><dt><b><a class="el" href="a00380.html#_compatibility_notes000021">Host Compatibility Notes:</a></b></dt><dd>Beginning in Pro Tools 11, AAX DSP algorithms also support optional temporary data spaces that can be described in the Describe module and are shared among all instances on a DSP. This is an alternative to declaring large data blocks on the stack for better memory management and to prevent stack overflows. Please refer to <a class="el" href="a00088.html#ad8daad601b60fdbd6134fe0c8faa2fc4">AAX_IComponentDescriptor::AddTemporaryData()</a> for usage instructions.</dd></dl>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__placing_data_into_external_memory_"></a>
Placing data into external memory</h3>
<div class="section"> An AAX plug-in may optionally request that its private data or program code be placed into external memory. Because standard access calls to the DSP's SDRAM are very slow, it is strongly recommended that all of a plug-in's real-time data be placed in internal RAM, and the TI Shell will load a plug-in's program code and all private plug-in data blocks into internal memory by default.</div><div class="section">Requesting more than 256 kB of data in internal memory for plug-in data plus the memory required by the TI Shell will lead to undefined behavior, so it is important to explicitly request external memory for plug-in data when appropriate.</div><div class="section">For private data blocks that should be loaded into external memory, use the <a class="el" href="a00206.html#a9f1ef2cb64daf30eaf145dfbb8cd0d00a75aef62fea40f9bba18502add99130b2">AAX_ePrivateDataOptions_External</a> flag when calling <a class="el" href="a00088.html#a125949841a13e97ff93fa321f2050433">AAX_IComponentDescriptor::AddPrivateData()</a> . This flag will be ignored by the host, so Native AAX plug-ins will have the same functionality with or without this property.</div><div class="section">To load program code, static data, or global variables into external memory, use the <code>TI SECTION</code> pragmas. For example, <code>#pragma CODE_SECTION_(".extmem")</code> can be used before function definitions that are either initialization code, or infrequently used background code. For static variables, use <code>#pragma DATA_SECTION_(".extmemdata")</code> before each variable definition.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__dma_support_"></a>
DMA support</h3>
<div class="section"> Because of the slower access time of external RAM, you should consider using a <a class="el" href="a00340.html">DMA transfer</a> for recurring transfers, and possibly even for larger one-time transfers. This is of particular relevance for data reads, which must traverse the various clock domains and priority switches twice (address send, and then data return.)</div><div class="section">The TI Shell supports three DMA modes: Scatter (for transfers from internal to external memory), Gather (for transfers from external to internal memory), and Burst (contiguous block copies). The Scatter mode can accomplish transfer speeds of up to 2.1 DSP cycles/byte transferred, while the Gather mode can accomplish 2.7 cycles/byte transferred.</div><div class="section">The Scatter and Gather DMA facilities use a linear buffer for internal memory and a FIFO for external memory. It is possible to transfer to or from multiple offsets within the external memory FIFO using an offset table, which can contain up to 65,536 (2̂16) entries. The offset (burst) length may be 4, 8, 16, 32, or 64 bytes long.</div><div class="section">The TI Shell also supports a Burst DMA mode which implements linear data reads or writes.</div><div class="section">For more information on DMA support and for example code, see <code>\ExamplePlugIns\DemoGain_DMA</code> in the SDK.</div><div class="section"></div><h2><a class="anchor" id="subsection__ti_shell_characteristics_data_packet_services"></a>
TI Shell characteristics: Data packet services</h2>
<div class="section"> In addition to supporting direct transfers of arbitrary data via DMA, the TI Shell also supports a packetized data delivery mechanism for host-to-DSP data transfers. Packet delivery ports may be either unbuffered or buffered, and are described using the <a class="el" href="a00206.html#ab5677b173ad8647c24d34d28272d11fc">AAX_EDataInPortType</a> parameter in <a class="el" href="a00131.html#a76ab9a0bef4cd6b6aa7144ed1adbe8a3">AAX_VComponentDescriptor::AddDataInPort()</a>.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__unbuffered_ports_"></a>
Unbuffered ports</h3>
<div class="section"> Unbuffered ports use a straightforward implementation that delivers posted packets to the algorithm as soon as possible. In an unbuffered port, newer packets will always override older packets. Therefore, an algorithm may not receive every packet that was posted to an unbuffered port, but it will always receive the most up-to-date information possible.</div><div class="section">Unbuffered ports deliver their data without blocking or synchronizing with the algorithm's execution. Although bus arbitration guarantees that a read from the algorithm callback will not occur in the middle of a write from the host, it is important to note that the data in an unbuffered port may change during algorithm execution.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__buffered_ports_"></a>
Buffered ports</h3>
<div class="section"> Buffered data ports store incoming packets in a host-managed queue. This queue acts as a buffer and provides the host with more flexibility in how it delivers packets. A key feature of buffered data ports is that new data will never be delivered to these ports during algorithm execution.</div><div class="section">The behavior of buffered data ports varies depending on the host platform. In HDX plug-ins, Buffered data ports use a FIFO to queue data packets as they are posted. New packets are dequeued and delivered to the algorithm individually, with the next packet arriving before each algorithm render callback.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__data_port_overhead_and_restrictions_"></a>
Data port overhead and restrictions</h3>
<div class="section"> Each HDX DSP supports a maximum of 164 buffered data ports, which matches the maximum I/O limit for each DSP. System overhead costs associated with using the on-chip packet services are as follows: </p><h4 class="Head3">Memory Overhead</h4>
</div><div class="section"> <ul>
<li class="Bullet">
The memory overhead for an unbuffered data port is simply the size of the data packet.  </li>
<li class="Bullet">
This DSP memory overhead for a buffered data port is two times the size of the data packet. A large (&gt;100-element) packet queue is also allocated on the host.  </li>
</ul>
<h4 class="Head3">CPU overhead</h4>
</div><div class="section"> Unbuffered ports do not incur any additional CPU overhead.</div><div class="section">Individual buffered ports do incur non-trivial CPU overhead. For example, in Pro Tools 10.2 each buffered port requires 5 cycles of overhead per render callback. This overhead can quickly add up in "small" plug-ins that contain many buffered data ports. Therefore, we strongly recommend that plug-ins use consolidated coefficient packets when possible in order to minimize this overhead. This optimization can result in large performance gains for callbacks that require 1000 or fewer cycles to operate.</div><div class="section">The trade-off of this optimization is that more work ends up being done on the host and more data must be transmitted to the algorithm, since the entire coefficient packet must be re-calculated and re-sent every time any of its input parameters change. This is usually beneficial trade-off to make, especially given the 128-byte per-transfer minimum discussed above. However, care must be taken in extreme cases such as when packet delivery threatens to bump up against the maximum recommended bandwidth for host/DSP data transfers.</div><div class="section"></div><h2><a class="anchor" id="subsection__ti_shell_characteristics_instance_allocation"></a>
TI Shell characteristics: Instance allocation</h2>
<div class="section"> </div><h3><a class="anchor" id="subsubsection__multishell_packing_"></a>
Multi-shell packing</h3>
<div class="section"> With a few exceptions, AAX DSP plug-ins will share DSPs with other plug-ins. This occurs transparently to the plug-in due to the fact that all system resource management is handled by the TI Shell.</div><div class="section">When a new plug-in instance is created, the TI Shell and AAX host will attempt to intelligently allocate it to a DSP based on both memory and CPU resource requirements. If one plug-in on the chip requires a large amount of memory and very few processing cycles, it may be packed with another plug-in that does not require much memory but that is very CPU intensive.</div><div class="section">The exceptions to this model are plug-ins that use DMA, register for a background processing callback, register a maximum number of instances per chip or use a processor affinity constraint when reporting CPU requirements. With the exception of a processor affinity, these plug-ins will receive dedicated DSPs to which only additional instances of the same plug-in type will be added.</div><div class="section"><dl class="compatibility_notes"><dt><b><a class="el" href="a00380.html#_compatibility_notes000022">Host Compatibility Notes:</a></b></dt><dd>Beginning with Pro Tools 10.2, the TI shell supports a "processor affinity" property, which indicates that a DSP ProcessProc should be preferentially loaded onto the same DSP as other instances from the same DLL binary. This is a requirement for some designs that must share global data between different processing configurations.<br />
 <br />
 Note that this property should only be used when absolutely required, as it will constrain the DSP manager and reduce overall DSP plug-in instance counts on the system.</dd></dl>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__dsp_shuffles_"></a>
DSP Shuffles</h3>
<div class="section"> A DSP shuffle will occur in Pro Tools when the engine must re-allocate DSP resources in order to make more processing power available. A shuffle will force the re-instantiation of the plug-in's DSP algorithm component, potentially on a new chip, while leaving the plug-in's host objects intact. During a shuffle, the engine will perform the following steps: </p><ol>
<li class="List">
Disconnect audio from an effect  </li>
<li class="List">
Call instance initialization with the removing instance flag on the old location  </li>
<li class="List">
Repeat for all instances of all DSP Effects in the system  </li>
<li class="List">
Load the effect in the new location  </li>
<li class="List">
Re-send the last packets to all data-in ports  </li>
<li class="List">
Call private data init for any private data  </li>
<li class="List">
Call instance init with the 'adding instance' flag, in the new location  </li>
<li class="List">
Begin audio processing  </li>
<li class="List">
Reconnect audio  </li>
<li class="List">
Repeat the instantiation and connection process for all instances of all DSP Effects in the system  </li>
</ol>
</div><div class="section">Note that the system may perform some audio processing with each new instance before all of the Effect instances in the system have been re-instantiated.</div><div class="section"></div><h2><a class="anchor" id="subsection__additional_ti_shell_services"></a>
Additional TI Shell services</h2>
<div class="section"></div><div class="section"></div><h3><a class="anchor" id="subsubsection__background_processing_"></a>
Background processing</h3>
<div class="section"> AAX plug-ins may request idle time from the main TIShell thread. This results in a true idle context callback which can be used for non-critical <a class="el" href="a00341.html">background processing</a> tasks on the DSP. This facility restricts the DSP to only allocate plug-in instances of the same type.</div><div class="section">A plug-in's background processing callback is not provided with a reference to the plug-in's data structures and must therefore access plug-in data via global variables. The background process will be interrupted by system events and the audio render callback. For more information and an example on how to create a plug-in that relies on background processing, see <code>\ExamplePlugins\DemoGain_Background</code> in the SDK. </div><div class="section"> </div><h1><a class="anchor" id="aax_ti_guide_03_requirements_for_ti_plug_ins"></a>
Requirements for TI Plug-Ins</h1>
<div class="section"></div><h2><a class="anchor" id="subsection__plugin_description"></a>
Plug-in description</h2>
<div class="section">To support AAX TI DSP platforms, a plug-in must add a TI ProcessProc (real-time processing entrypoint) for each of its algorithms. This is done via a call to <a class="el" href="a00088.html#aa8443e720e48046444a2e9f712f0864b" title="Registers an algorithm processing entrypoint (process procedure) for the native architecture. ">AAX_IComponentDescriptor::AddProcessProc_TI()</a>, which is parametrized with the names of both the algorithm's TI DLL and of its exported entrypoint.</div><div class="section">At minimum, the TI ProcessProc requires the following AAX Properties: </p><ul>
<li class="Bullet">
A TI plug-in ID: <a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea75f174df4efbeca86eaada126c1d9214">AAX_eProperty_PlugInID_TI</a>  </li>
<li class="Bullet">
The audio buffer size that will be used by the ProcessProc: <a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea09fbd1cbcae0e86ad81005258dc1b67e">AAX_eProperty_DSP_AudioBufferLength</a>, set with a value from <a class="el" href="a00206.html#ab33e0f1ecf04ca4161fa8d8de5845d67">AAX_EAudioBufferLengthDSP</a>  </li>
</ul>
</div><div class="section"></div><h2><a class="anchor" id="subsection__performance_measurement_and_reporting"></a>
Performance measurement and reporting</h2>
<div class="section">In order to determine each algorithm's resource requirements, the host collects cycle count information from the plug-in via the plug-in's Describe callback. Each plug-in Effect is responsible for correctly reporting its algorithms' cycle counts for each accelerated platform that it supports. For plug-ins that use DMA or background threads, a maximum per-chip instance count is also required.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>All reported values must represent the algorithm's worst case performance.</dd></dl>
<p>Each of these values are reported as properties of a given algorithm ProcessProc and are provided by the plug-in via <a class="el" href="a00088.html#aa8443e720e48046444a2e9f712f0864b">AAX_IComponentDescriptor::AddProcessProc_TI()</a>. If an effect does not report its cycle count usage then it will be limited to a single instance per TI chip. This can be useful during development, but is not a supported mode for general use; all shipped plug-ins must correctly report their cycle requirements.</div><div class="section">Development Builds of Pro Tools include DigiShell, a utility that can be used to accurately measure plug-in cycle count requirements. For more information about DigiShell, see <a class="el" href="a00365.html">DSH Guide</a>.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__shared_vs_perinstance_cycles_"></a>
Shared vs. per-instance cycles</h3>
<div class="section"> Because a single call into a plug-in is used to process multiple instances of that effect on that chip, two cycle count properties must be reported for each TI algorithm: </p><ol>
<li class="List">
<a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea3e5b289333ba49f5a33de40d89fa4ade">AAX_eProperty_TI_SharedCycleCount</a> <div class="TextInd1"> This property describes the algorithm's one-time processing overhead that doesn't change as instances are added to a chip.</div>  </li>
<li class="List">
<a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea5d8e5be9f3698a9c67a578c29da66405">AAX_eProperty_TI_InstanceCycleCount</a> <div class="TextInd1"> This property describes the additional cycle counts that each instance adds to the base shared overhead.</div>  </li>
</ol>
</div><div class="section">Many plug-ins exhibit different performance characteristics for both of these metrics depending on the plug-in's state. When reporting a plug-in's shared and per-instance cycle count requirements it is important to ensure that the reported values are the <em class="Bold">maximum possible requirements</em> of the algorithm.</div><div class="section">Often a plug-in will experience its worst-case per-instance processing load in one configuration and its worst-case shared processing load in another configuration. In this situation, the plug-in's reported cycle count requirements should reflect the state in which the <em class="Italic">sum</em> of the two metrics is highest.</div><div class="section">It's a common practice to not describe <a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea5d8e5be9f3698a9c67a578c29da66405">AAX_eProperty_TI_InstanceCycleCount</a> and <a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea3e5b289333ba49f5a33de40d89fa4ade">AAX_eProperty_TI_SharedCycleCount</a> for the plug-ins during development and debugging process of the DSP plug-ins. This is acceptable, although in this case the one instance of such a plug-in will require the whole chip. In AAX SDK example plug-ins this is implemented using <code>AAX_TI_BINARY_IN_DEVELOPMENT</code> macros. If defined, it turns off the cycle count properties for the plug-in.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__measuring_shared_cycles_"></a>
Measuring shared cycles</h3>
<div class="section"> Measuring shared cycle counts requires instantiating multiple instances of an effect and observing how the processing time changes as instances are added. The shared and instance cycle counts are then calculated by performing a linear regression on the number of uncached cycle counts as the number of plug-in instances on the chip increases.</div><div class="section">Note that these values will differ between debug and release builds of an algorithm, so a plug-in's describe function should report the correct cycle count values based on the relevant build configuration.</div><div class="section">DigiShell includes the ability to measure shared cycle counts using the <code>DAE.cyclesshared</code> command. For more information about performance profiling using DigiShell, see <a class="el" href="a00365.html#subsection__cyclessharedtest">Cycle count performance test</a>.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>HDX requires reporting of an algorithm's <em class="Bold">worst-case</em> cycle counts.</dd></dl>
</div><h3><a class="anchor" id="subsubsection__dma_and_background_thread_performance_reporting_"></a>
DMA and background thread performance reporting</h3>
<div class="section"> For algorithms that use <a class="el" href="a00340.html">DMA</a> or <a class="el" href="a00341.html">background thread</a> facilities, the maximum number of algorithm instances that will fit on a chip is difficult to predict from cycle counts alone. Due to the asynchronous behavior and limited capacity of the DMA system, the DMA system may begin to miss its deadlines before the CPU is fully loaded. In addition, due to differences in background processing requirements between algorithms, an effect's background process may begin to miss its deadlines and be starved before the interrupt-time audio processing is at capacity. Plug-ins that use these facilities must therefore report the maximum number of instances that will run reliably at a given sample rate, in addition to reporting their shared and per-instance cycle counts as above.</div><div class="section">Maximum reliable instance counts are reported using an additional property, <a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea5b85e213113b7f0f7ee4bac4f5eaa59d">AAX_eProperty_TI_MaxInstancesPerChip</a>. A plug-in should register separate components for the following three sample rate ranges in order to register distinct values for this property: </p><ol>
<li class="List">
Sample rates from 42kHz to 50kHz  </li>
<li class="List">
Sample rates from 84kHz to 100kHz  </li>
<li class="List">
Sample rates from 168kHz to 200kHz  </li>
</ol>
</div><div class="section">Notes regarding DMA and background thread performance reporting: </p><ul>
<li class="Bullet">
Because the number of instances will decrease as sample rate increases, the plug-in must be tested at the highest available pulled-up sample rate (i.e. 50kHz instead of 48kHz) in each of these three ranges.  </li>
<li class="Bullet">
On the HDX platform, effects that use DMA or background threads will not be mixed with effects of other types on a given chip.  </li>
<li class="Bullet">
The maximum number of instances per DSP cannot be measured via DSH in these cases, so careful listening tests must be manually performed in order to determine whether a certain number of instances of a DMA or background-enabled plug-in actually operate correctly on a DSP. </li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__dynamic_resource_usage_"></a>
Dynamic resource usage</h3>
<div class="section"> All resources used by an AAX DSP plug-in algorithm are considered static. Plug-ins may not dynamically change the amount of memory or DSP cycles that are allocated to them after these metrics are provided in Describe.</div><div class="section">The ability to dynamically change DSP cycle count requirements at run time is provided in the AAX SDK but is not currently supported by any host.</div><div class="section"></div><h2><a class="anchor" id="subsection__plugin_compilation_and_packaging"></a>
Plug-in compilation and packaging</h2>
<div class="section"> </div><h3><a class="anchor" id="subsubsection__exported_symbols_"></a>
Exported symbols</h3>
<div class="section"> Each TI algorithm (ELF DLL) may contain multiple entrypoints. A single DLL may be used for all of your plug-in's entrypoints and program code, or you may divide your plug-in's entrypoints and program code between multiple DLLs.</div><div class="section">Your plug-in must export one "C"-style callback for each algorithm ProcessProc that your plug-in registers. This entrypoint must conform to the standard AAX real-time algorithm callback prototype:</div><div class="section"><div class="fragment"><div class="line"><span class="preprocessor"># include &quot;elf_linkage.h&quot;</span> <span class="comment">// Includes required TI_EXPORT definition</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line">TI_EXPORT</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">MyEffect_AlgorithmProcessFunction(</div>
<div class="line">    SMyEffect_Alg_Context * <span class="keyword">const</span>  inInstancesBegin  [],</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">void</span> *    inInstancesEnd)</div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 1.1: The standard AAX real-time algorithm callback prototype</div></div><div class="section">For Code Composer Studio projects from Code Composer Studio version 5 and higher (running Code Generation Tools 7.4.x or higher), you should include the following header instead of elf_linkage.h:</div><div class="section"><div class="fragment"><div class="line"><span class="preprocessor"># include &quot;elf_linkage_aax_ccsv5.h&quot;</span></div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 1.2: Header which should be included into all CCSv5 plug-in projects.</div></div><div class="section">It is located in AAX_SDK/TI/CCSv5 folder, so you will also need to add this path to the include path of your projects.</div><div class="section"><dl class="section note"><dt>Note</dt><dd><ul>
<li>
There is a compiler option in Code Composer Studio that will add an underscore to the exported entrypoint's name. We recommend keeping this option disabled in order to avoid ambiguity between the exported symbol name and the function name as it appears in your source code.  </li>
<li>
If you encounter undefined symbol errors when linking to a DSP library that uses a C-style interface then add the extern "C" keyword before the lib function prototypes. This should resolve the majority of such linker errors. </li>
</ul>
</dd></dl>
</div><h3><a class="anchor" id="subsubsection__packaging_"></a>
Packaging</h3>
<div class="section"> The ELF DLLs for an AAX DSP plug-in must be placed in the ./Content/Resources directory within the plug-in bundle. </div><div class="section"> </div><h1><a class="anchor" id="aax_ti_guide_04_ti_development_tools"></a>
TI Development Tools</h1>
<div class="section">Development for TI algorithms is primarily performed in TI's Code Composer Studio. Code Composer Studio (CCS) is a full-featured, Eclipse-based IDE providing JTAG hardware debugger support, a hardware simulator, and a suite of profiling tools. Most importantly, CCS includes an excellent C compiler that is capable of providing highly optimized DSP instructions without too much tuning.</div><div class="section"> <dl class="section note"><dt>Note</dt><dd>As of this writing, Code Composer Studio for Mac does not support the C6000 series processor. CCS for Windows is required for AAX DSP plug-in development. See <a href="http://processors.wiki.ti.com/index.php/MacOS_Host_Support_CCSv7">MacOS Host Support CCSv7</a> on the Texas Instruments wiki for current compatibility information.</dd></dl>
</div><h2><a class="anchor" id="subsection__code_composer_studio"></a>
Code Composer Studio</h2>
<div class="section">The AAX SDK supports Code Composer Studio versions 4 ("CCSv4") and higher ("CCSv5", etc.), with hardware debugging support beginning in version 4.2. As of the writing of this documentation, CCS versions 4, 5, and 7 have been tested by Avid.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>This documentation was originally written for CCSv4 and was later updated with instructions for updating from CCSv4 to CCSv5. Versions 5 and higher use a different project file format from version 4; when this documentation describes changes required for version 5 then these changes will also be required by other later versions which use this new project format.</dd></dl>
</div><h3><a class="anchor" id="subsubsection__installation_"></a>
Installation</h3>
<div class="section"><ol>
<li class="List">
<p class="startli">Download and install the latest Code Composer Studio from TI's website.</p>
<dl class="section note"><dt>Note</dt><dd>Windows 10 requires Code Composer Studio version 6.1.3 or higher</dd>
<dd>
As of Code Composer Studio version 7 TI does not charge for licenses. You can simply download the tool and start using it. Along with this the end user license agreement has changed to a simple TSPA compatible license. For more information see the TI web site.  </dd></dl>
</li>
<li class="List">
The default installation will work fine, but a custom install will be smaller. You only need support for the C6000 chipset and the Spectrum Digital JTAG drivers, so you can deselect all the other chipsets and JTAG drivers.  </li>
<li class="List">
Go to<em class="Comment"> </em> <em class="Hyperlink"> <a href="https://www-a.ti.com/downloads/sds_support/TICodegenerationTools/download.htm" class="URL">TI's Code Generation Tools</a></em> <em class="Comment"> </em> page. You will need to log in. </li>
<li class="List">
<p class="startli">Download and install the C6000 Code Generation Tools v7.0.x or later, using the typical installation settings. For <a class="el" href="a00288.html">AAX</a> DSP development you will only need support for the C6000 chipset and, if you will be using a hardware debugger, for the Spectrum Digital JTAG drivers, so you may deselect all the other chipsets and JTAG drivers.</p>
<ol>
<li class="List">
Launch CCS and go to Help &gt; Install New Software...  </li>
<li class="List">
In the opened dialog select "Code Generation Tools Updates" in the "Work with:" drop-down list.  </li>
<li class="List">
Select "TI Compiler Updates" &gt; "C6000 Compiler Tools [version]".  </li>
<li class="List">
Press Next and continue installation using the "typical" installation settings. </li>
</ol>
<p>As of the publishing of this version of the AAX SDK Avid is internally using v7.4.6. Avid has tested 7.4.4 and 7.4.6, but we assume that later revisions will work as well. The latest CGTools version available as of this writing is v7.4.21.</p>
<p class="endli">For more information about configuring your CCS workspace with CGTools v7.4.x, see <a class="el" href="a00362.html#subsubsection__workspace_setup_">Workspace setup</a> </p>
</li>
</ol>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__workspace_setup_"></a>
Workspace setup</h3>
<div class="section"> The idea of a CCS workspace is similar to a Visual Studio solution file. Note that workspaces tend to store absolute paths and developer-specific info, so you may wish to avoid checking them in to your source control server. </p><h4 class="Head3">Setting up workspace-global macros </h4>
</div><div class="section"> <em class="Infinitive"> To set up workspace global macros: </em> </p><ol>
<li class="List">
When you open CCS for the first time, select a directory for your "workspace". As mentioned above, we recommend that this be outside of your source tree.  <dl class="section note"><dt>Note</dt><dd>Pay attention that you can not reuse your Code Composer Studio workspace after updating to a later versions. In particular, we have found the CCSv4 workspaces are incompatible with CCSv5. After updating your system to a later Code Composer Studio version you must create a new workspace and import your existing projects into this new workspace. </dd></dl>
</li>
<li class="List">
Go to File &gt; Import... and select Code Composer Studio &gt; Build Variables (CCS &gt; Managed Build Macros in CCSv4.) Click Next.  </li>
<li class="List">
Browse to TI/Common/macros.ini in your AAX SDK directory and click Finish.  </li>
<li class="List">
This will define an "SDK_SOURCE_ROOT" Linked Resource path variable and Managed Build macro, which associates the CCS workspace with a single AAX SDK installation. <dl class="section note"><dt>Note</dt><dd>A side effect of this is that you cannot use projects from multiple distinct AAX SDK installations in the same CCS workspace.  </dd></dl>
</li>
<li class="List">
To verify that the correct path has been set, go to Window &gt; Preferences... and look in General &gt; Workspace &gt; Linked Resources, and C/C++ &gt; Build &gt; Build Variables (C/C++ &gt; Managed Build &gt; Macros for CCSv4.) </li>
</ol>
<h4 class="Head3">Importing projects into your workspace </h4>
</div><div class="section"> <em class="Infinitive"> To import projects into your workspace:</em> </p><ol>
<li class="List">
In the IDE, go to Project &gt; Import Existing CCS/CCE Eclipse Project  </li>
<li class="List">
In Select search-directory, select the root of your AAX SDK installation  </li>
<li class="List">
The projects in the resulting Projects list will automatically be selected  </li>
<li class="List">
Click Finish, and then wait while the projects are imported.  </li>
</ol>
</div><div class="section">In order to import CCSv4 projects into later versions of Code Composer Studio it is necessary to add a .cdtproject file to the project. If you don't have this file in your project, then you can copy it from any other existing project which was created using CCSv5 or later. Otherwise you will most likely see something similar to this error:</div><div class="section"><em class="Italics"></p><blockquote class="doxtable">
<p>"Error: Import failed for project 'xxxx' because its meta-data cannot be interpreted."</p>
</blockquote>
<p></em></div><div class="section">If you try to build this newly imported CCSv4 project in a later version of Code Composer Studio then you will get the warning:</div><div class="section"><em class="Italics"></p><blockquote class="doxtable">
<p>"This project was created using a version of compiler that is not currently installed: 7.0.5 [C6000]. Another version of the compiler will be used during build: 7.4.6. Please install the compiler of the required version, or migrate the project to one of the available compiler versions by adjusting project properties."</p>
</blockquote>
<p></em></div><div class="section">This warning may be cleared by changing Properties &gt; General &gt; Compiler Version from TI v7.0.x to the current version (e.g. TI v7.4.x). After that the <em>"Output format"</em> field, which is next one to the <em>"Compiler version"</em> field and is typically grayed out, will become active. You should choose "eabi (ELF)" there. Otherwise Code Composer the build will fail with errors: </p><ul type="none">
<li>
<em class="Italics">"--dynamic=lib not supported when producing TI-COFF output files"</em> </li>
<li>
<em class="Italics">"--export=_auto_init_elf not supported when producing TI-COFF output"</em> </li>
</ul>
</div><div class="section"><dl class="section note"><dt>Note</dt><dd>After successful convertion of the project and successful build, the remeasurement of cycle count should be done, because it may change. Most likely it will decrease, as compared to the version which was built with CCSv4, but that is not guaranteed. Also the size of the DLL may increase, which may require reducing code size in order to properly instantiate the plug-in.</dd></dl>
</div><h3><a class="anchor" id="subsubsection__creating_new_projects_"></a>
Creating new projects</h3>
<div class="section"><h4 class="Head3">New project setup</h4>
</div><div class="section"> <em class="Infinitive"> Use the following settings in the "New Project..." wizard. Defaults are in italics.</em> </p><ul>
<li class="SingleStep">
Project Type: <code>C6000</code>  </li>
<li class="SingleStep">
Output type: <code>Executable</code>  </li>
<li class="SingleStep">
Device Variant: <code>Generic C67x+ Device</code>  </li>
<li class="SingleStep">
Device Endianness: <code>little</code>  </li>
<li class="SingleStep">
Code Generation Tools: <code>7.4.6</code> or later (<code>7.0.5</code> for CCSv4)  </li>
<li class="SingleStep">
Output format: eabi (ELF) (in CCSv4 this field will be grayed out.) </li>
<li class="SingleStep">
Linker Command File: <code>CommonPlugIn_LinkerCmd.cmd</code> (see note below)  </li>
<li class="SingleStep">
Runtime Support Library: <em class="Italic"> &lt;automatic&gt;</em>  </li>
</ul>
</div><div class="section"><dl class="section note"><dt>Note</dt><dd>You can edit the Linker Command File setting to use the <code>SDK_SOURCE_ROOT</code> macro by manually editing the project's .project XML file or by adding the file to your project using a relative path. See the SDK sample plug-in projects for an example.</dd></dl>
</div><h3><a class="anchor" id="subsubsection__recommended_settings_for_aax_plugin_projects_"></a>
Recommended settings for AAX plug-in projects</h3>
<div class="section"> <div> Tool Settings </div> <div class="TextInd1"> C6000 Compiler </div> <div class="TextInd2"> Include Options </div> <div class="TextInd3"> -<code>include_path "${SDK_SOURCE_ROOT}/Interfaces"</code></div> <div class="TextInd3"> -<code>include_path "${SDK_SOURCE_ROOT}/[Plug-in directory]"</code></div></div><div class="section">The <code>SDK_SOURCE_ROOT</code> macro is defined via the macros.ini file, located in the SDK's /TI/CCSv4 directory. If you encounter errors using this macro, import the file using File &gt; Import... &gt; CCS &gt; Managed Build Macros.</div><div class="section"><div> Tool Settings </div> <div class="TextInd1"> C6000 Compiler </div> <div class="TextInd2"> Command Files </div> <div class="TextInd2"> <code>-cmd_file "${SDK_SOURCE_ROOT}\\TI\\CCSv4\\CommonPlugIn_CompilerCmd.cmd"</code></div></div><div class="section">This file contains additional compiler commands that should be common to all AAX plug-in projects</div><div class="section"><div> Tool Settings </div> <div class="TextInd1"> C6000 Linker </div> <div class="TextInd2"> Basic Options </div> <div class="TextInd2"> <code>-o "${ConfigDir}/${PackageName}/Contents/Resources/${ProjName}.dll"</code></div></div><div class="section">This path will ensure that your compiled TI DLL is placed in the appropriate location inside your AAX plug-in bundle.</div><div class="section"><div> Tool Settings </div> <div class="TextInd1"> C6000 Linker </div> <div class="TextInd2"> Runtime Environment </div> <div class="TextInd3"> (No "Initialization model" options set)</div><p> <br />
 </p><div> Build Settings </div> <div class="TextInd1"> Artifact name </div> <div class="TextInd2"> <code>${ConfigDir}/${PackageName}/Contents/Resources/${ProjName}</code></div></div><div class="section">This path will ensure that your compiled TI DLL is placed in the appropriate location inside your AAX plug-in bundle.</div><div class="section"><div> Build Settings </div> <div class="TextInd1"> Artifact extension </div> <div class="TextInd2"> <code>dll</code></div></div><div class="section">AAX TI libraries should use the .dll extension</div><div class="section"><div> Binary Parser </div> <div class="TextInd1"> Elf Parser</div></div><div class="section">AAX TI libraries should use the Elf binary parser only</div><div class="section"><div> Macros </div> <div class="TextInd1"> Project </div> <div class="TextInd2"> User Macros </div> <div class="TextInd3"> ConfigDir = <code>${OutDir}/${ConfigName}</code></div> <div class="TextInd3"> IntDir = <code>${ConfigDir}/int/${PackageName}/TI/${ProjName}</code></div> <div class="TextInd3"> OutDir = <code>${ProjDirPath}/../../WinBuild</code></div> <div class="TextInd3"> PackageName = [Plug-in name]</div></div><div class="section">These macros are used by the other settings here to ensure proper path set-up and artifact naming. Don't worry that <code>ConfigName</code> shows up as undefined - it will be defined as Debug/Release at compilation.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__recommended_release_configuration_settings_"></a>
Recommended Release configuration settings</h3>
<div class="section"> <div> Tool Settings </div> <div class="TextInd1"> C6000 Compiler </div> <div class="TextInd2"> Basic Options </div> <div class="TextInd3"> <code>-symdebug:none</code></div> <div class="TextInd3"> <code>-O3</code></div></div><div class="section"><div> Tool Settings </div> <div class="TextInd1"> C6000 Compiler </div> <div class="TextInd2"> Predefined Symbols </div> <div class="TextInd3"> <code>-define=NDEBUG</code></div></div><div class="section"><div> Tool Settings </div> <div class="TextInd1"> C6000 Compiler </div> <div class="TextInd2"> Optimizations </div> <div class="TextInd3"> <code>-os</code></div> <div class="TextInd3"> <code>-on2</code></div> <div class="TextInd3"> <code>-op3</code></div></div><div class="section"><div> Tool Settings </div> <div class="TextInd1"> C6000 Compiler </div> <div class="TextInd2"> Assembler Options </div> <div class="TextInd3"> <code>-keep_asm</code> </div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__other_useful_project_settings_"></a>
Other useful project settings</h3>
<div class="section"> <div> Tool Settings </div> <div class="TextInd1"> C6000 Compiler </div> <div class="TextInd2"> Predefined Symbols </div> <div class="TextInd3"> <code>-define _DEBUG</code></div></div><div class="section">This option is useful for differentiating cycle count reporting for Debug vs. Release builds.</div><div class="section"><div> Tool Settings </div> <div class="TextInd1"> C6000 Compiler </div> <div class="TextInd2"> Directory Specifier </div> <div class="TextInd3"> <code>-ft "${IntDir}"</code></div> <div class="TextInd3"> <code>-fr "${IntDir}"</code></div> <div class="TextInd3"> <code>-fs "${IntDir}"</code></div></div><div class="section">Useful for collecting intermediate files</div><div class="section"><div> Tool Settings </div> <div class="TextInd1"> C6000 Linker </div> <div class="TextInd2"> Basic Options </div> <div class="TextInd3"> <code>-m "${IntDir}/${ProjName}.map"</code></div></div><div class="section">Useful for placing the map file alongside all other intermediates</div><div class="section"><div> Tool Settings </div> <div class="TextInd1"> C6000 Linker </div> <div class="TextInd2"> File Search Path </div> <div class="TextInd3"> <code>-l (nothing)</code></div></div><div class="section">You can exclude libc.a, which is included by default, from this option unless you require C library features.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__adding_files_and_folders_"></a>
Adding files and folders</h3>
<div class="section"> In CCS, dragging files into the project, using "Add Files to Project...", or using "Link Files to Project..." will either copy the file into the project directory or create an absolute path to the file. This is usually not the desired behavior. Use the following steps to add a file using a relative path: <em class="Infinitive"> &#160;</em> </p><ol>
<li class="List">
Right click on the project you'd like to add files to, and select New &gt; File (NOT "Source File" or "Header File").  </li>
<li class="List">
Click "Advanced &gt;&gt;".  </li>
<li class="List">
Check the box that says "Link to the file in the system". Click "Variables..."  </li>
<li class="List">
Select the appropriate variable (usually either <code>SDK_SOURCE_ROOT</code> or <code>SOURCE_ROOT</code>) and click "Extend..."  </li>
<li class="List">
Find the file you want to add. Click OK. Click Finish.  </li>
</ol>
</div><div class="section">Note that, when adding folders, <em>everything</em> in the folder will be built by default. You can exclude files to work around this behavior.</div><div class="section"></div><h2><a class="anchor" id="subsection__the_tms320c6000_cpp_compiler"></a>
The TMS320C6000 C++ compiler</h2>
<div class="section"> One of the primary goals of AAX is to provide a platform-agnostic development architecture in which products can easily be developed and re-used across a wide variety of platforms. However, it is still occasionally necessary to write platform-specific code. This section will document methods for producing code that is specific to the TI C6727 platform using the TMS320C6000 C++ compiler.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__cpp_standard_support_"></a>
C++ standard support</h3>
<div class="section"> The TMS320C6000 compiler supports C++ as defined in the ISO/IEC 14882:1998 standard. The exceptions to the standard are as follows: </p><ul>
<li class="Bullet">
Complete C++ standard library support is not included. C subset and basic language support is included.  </li>
<li class="Bullet">
These C++ headers for C library facilities are not included: <ul>
<li class="DashInd">
<code>&lt;clocale&gt; </code> </li>
<li class="DashInd">
<code>&lt;csignal&gt;</code>  </li>
<li class="DashInd">
<code>&lt;cwchar&gt;</code>  </li>
<li class="DashInd">
<code>&lt;cwctype&gt;</code>  </li>
<li class="DashInd">
<code>&lt;ciso646&gt;</code>  </li>
</ul>
</li>
<li class="Bullet">
These C++ headers are the only C++ standard library header files included: <ul>
<li class="DashInd">
<code>&lt;new&gt;</code>  </li>
<li class="DashInd">
<code>&lt;typeinfo&gt;</code>  </li>
</ul>
</li>
<li class="Bullet">
No support for <code>bad_cast</code> or <code>bad_type_id</code> is included in the typeinfo header.  </li>
<li class="Bullet">
Run-time type information (RTTI) is disabled by default. RTTI can be enabled with the -rtti compiler option.  </li>
<li class="Bullet">
The <code>reinterpret_cast</code> type does not allow casting a pointer to member of one class to a pointer to member of a another class if the classes are unrelated.  </li>
<li class="Bullet">
Two-phase name binding in templates, as described in tesp.res and temp.dep of the standard, is not implemented.  </li>
<li class="Bullet">
The export keyword for templates is not implemented.  </li>
<li class="Bullet">
A typedef of a function type cannot include member function cv-qualifiers.  </li>
<li class="Bullet">
A partial specialization of a class member template cannot be added outside of the class definition.  </li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__predefined_environment_symbols_"></a>
Predefined environment symbols</h3>
<div class="section"> The following symbols are predefined by the compiler on the TI architecture, and should be used in code concerned with cross-platform support:</div><div class="section"><ul>
<li class="Bullet">
<code>_TMS320C6X</code> Identifies that the chip is a C6000 variant. This is the symbol that we commonly use to distinguish whether code is being compiled for AAX-Native (Mac/Windows) or AAX-TI. </li>
<li class="Bullet">
<code>_TMS320C6700_PLUS</code> Identifies that the chip is a C6700-plus variant  </li>
</ul>
</div><div class="section">Although you should not require them for AAX development, equivalent assembly predefines are as follows:</div><div class="section"><ul>
<li class="Bullet">
<code>.TMS320C6X</code> Identifies that the chip is a C6000 variant  </li>
<li class="Bullet">
<code>.TMS320C6700_PLUS</code> Identifies that the chip is a C6700-plus variant </li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__loop_controls_"></a>
Loop controls</h3>
<div class="section"> The TI compiler supports several pragmas that can be used to give the compiler additional information about loops.</div><div class="section"><ul>
<li class="Bullet">
<code>#pragma MUST_ITERATE( min, max, multiple )</code> <div> This pragma helps the compiler optimize loops. min is the minimum number of times the loop will execute, max is the maximum number of times the loop will execute, and modulo is used if the loop will only execute a certain multiple of some number.</div> <br />
  </li>
<li class="Bullet">
<code>#pragma PROB_ITERATE( min , max )</code> <div> If extreme cases prevent the use of <code>MUST_ITERATE</code>, <code>PROB_ITERATE</code> allows you to specify the usual number of times a loop executes. For example, <code>PROB_ITERATE</code> could be applied to a loop that executes for eight iterations in the majority of cases but that sometimes may execute more or less than eight iterations.</div> <br />
  </li>
<li class="Bullet">
<code>pragma UNROLL( n )</code> <div> Helps the compiler use SIMD instructions, where <code>n</code> is the unrolling factor. By specifying <code>UNROLL(1)</code> you can prevent the compiler from automatically unrolling a loop. In general, we recommend using <code>MUST_ITERATE</code> instead unless you have specifically identified a situation where manually unrolling a loop improves performance.</div>  </li>
</ul>
</div><div class="section"></div><h2><a class="anchor" id="subsection__digishell_test_tool"></a>
DigiShell test tool (DSH)</h2>
<div class="section"> DigiShell is a software tool that provides a general framework for running tests on Avid audio hardware. As a command-line application, DigiShell may be driven as part of a standard, automated test suite for maximum test coverage. DSH supports loading all types of AAX plug-ins including Native and DSP, and is especially useful when running performance and cancellation tests of AAX-TI types. DigiShell is included in Pro Tools Development Builds as <code>dsh.exe</code> (Windows) or as <code>dsh</code> in the <code>CommandLineTools</code> directory (Mac).</div><div class="section">More information on DSH test tool can be found in <a class="el" href="a00365.html">DSH Guide</a>.</div><div class="section"></div><h2><a class="anchor" id="subsection__hardware_debugging"></a>
Hardware Debugging</h2>
<div class="section"> </div><h3><a class="anchor" id="subsubsection__requirements_"></a>
Requirements</h3>
<div class="section"> Relocatable ELF DLLs (TI algorithms) can be debugged with some help from the DIDL loader, the TI Shell Manager, and a script called DLLView_Elf_Avid.js.</div><div class="section">These are the minimum requirements for hardware debugging for TI plug-ins: </p><ul>
<li class="Bullet">
Code Composer Studio version 4.2 or later  </li>
<li class="Bullet">
XDS510 hardware debugger  </li>
<li class="Bullet">
JTAG-enabled HDX card  </li>
</ul>
</div><div class="section">We recommend using Spectrum Digital's XDS510 USB Plus JTAG Emulator, as it is the only one our internal developers have used and tested in-house. Both Spectrum Digital and TI have useful technical reference/installation guides, both of which can be found on the AAX Developer Forum under the 'Development Tools' discussion.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__how_it_works_"></a>
How it works</h3>
<div class="section"> The ridl ELF loader inside DIDL stores a module and segment list containing the paths of all loaded modules and where their segments are loaded. The TI Shell Manager gets a serialized version of this table and loads it to a block of external memory on the chip at a known location. The DLLView_Elf_Avid.js script queries this memory via the debugger and extracts the paths of the modules and the ELF segment load locations, which it then passes on to the <code>GEL_SymbolAddELFRel</code> scripting console command (new to CCSv4.2). You can also use that command directly at the console.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__connecting_a_jtag_emulator"></a>
Connecting a JTAG Emulator</h3>
<div class="section"> A JTAG-enabled HDX development card includes a "riser" PCB section extending about a centimeter above the production card PCB. This riser includes two JTAG connectors. The two connectors correspond to the two banks of 9 DSPs on the HDX card. Assuming that you are instantiating your plug-in for debugging on the first available DSP, you will want to connect your JTAG emulator to the connector that is closest to the card's user-visible ports. This connector corresponds to the first 9 DSPs on the card.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__linking_to_tishellout_"></a>
Linking to TIShell.out</h3>
<div class="section"> Hardware debugging, as well as several other debugging facilities, requires that the DSP plug-in project is linked to TIShell.out in Code Composer Studio.</div><div class="section"><em class="Infinitive"> To link a plug-in project to TIShell.out, follow these steps:</em> </p><ol>
<li class="List">
Open the plug-in project's properties window and navigate to the <em class="Italic">C/C++ Build &gt; Tool Settings &gt; C6000 Linker &gt; File Search Path</em> properties pane.  </li>
<li class="List">
Add "TIShell.out" to the "Include library file" (<code>-l</code>) property list.  </li>
<li class="List">
Under "Add &lt;dir&gt; to library search path" (<code>-i</code>), add the file path of the Pro Tools build you will be using to test the plug-in. This directory should already include the build's TIShell.out file.  </li>
<li class="List">
Repeat this process for each Configuration of the plug-in project that you will be testing.  </li>
<li class="List">
Add "[path to AAX SDK root]\\TI" to the project's list of source file include directories  </li>
</ol>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__adding_the_hdx_target_descriptor_file_"></a>
Adding the HDX Target Descriptor File</h3>
<div class="section"> <em class="Infinitive"> To add the HDX Target Descriptor File:</em> </p><ol>
<li class="List">
In the IDE, go to Window &gt; Preferences, CCS &gt; Debug. Point the "Shared target configuration directory" to /TI/Common in your AAX SDK source tree  </li>
<li class="List">
In the IDE, go to Window &gt; Show View &gt; Target Configurations.  </li>
<li class="List">
Click refresh if you don't see the configuration file  </li>
<li class="List">
Right click Raven_C672x_XDS510_USB.ccxml, and click "Set as Default".  </li>
</ol>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__setting_up_the_dllview_script_"></a>
Setting up the DLLView script</h3>
<div class="section"> Once you have successfully installed the XDS510, you will have to do a little bit of setup with CCS. Before starting this process, verify that you are running CCSv4.2 or later and the C6000 code generation tools v7.4 or later (or 7.0.5 for CCSv4). CCS should recognize the installed emulator and prompt you to download the necessary drivers. Once completed, you will then want to setup your DLLView script.</div><div class="section"><em class="Infinitive"> To set up the DLLView script:</em> </p><ol>
<li class="List">
In the IDE, open the Scripting Console under View &gt; Scripting Console  </li>
<li class="List">
At the Scripting console, type one of the following to load the DLLView script (insert your own source tree path, and make sure to load the version that corresponds to your installed CCS version): <div class="TextInd1"> Code Composer Studio 4: <code>loadJSFile "[PATH TO AAX SDK]/TI/CCSv4/dllView_Elf_Avid.js" true </code> Code Composer Studio 5 and later: <code>loadJSFile "[PATH TO AAX SDK]/TI/CCSv5/dllView_Elf_Avid.js" true </code></div>  </li>
</ol>
</div><div class="section">You should now see a new menu item under the Scripts menu: "DLLView -Load Pro Tools Plug-In Symbols" This should load every time CCS starts.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__loading_symbols_for_debugging_"></a>
Loading Symbols for Debugging</h3>
<div class="section"> You will need to get your code loaded and running on the TI before you load symbols. You can do this directly through Pro Tools, or by using our DigiShell test tool. If using the DigiShell test tool, load the DAE dish and then a plug-in via the following commands: </p><div class="TextInd1"> <code>load_dish DAE</code> </div> <div class="TextInd2"> Loads the DAE dish</div> <div class="TextInd1"> <code>run </code></div> <div class="TextInd2"> Lists available plug-ins with their index and spec</div> <div class="TextInd1"> <code>run&lt;index&gt;</code> </div> <div class="TextInd2"> Instantiates the &lt;index&gt; plug-in</div></div><div class="section">Use the DLLView script to load symbols for ELF DLLs. After setting up the DLLView script and connecting to the desired chip in the Debug pane, run the "DLLView -Load Pro Tools Plug-In Symbols" script from the Scripts menu in Code Composer Studio.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>The chip will need to be Suspended in the debugger in order to load symbols.</dd></dl>
<p><em class="Infinitive"> To load symbols for debugging:</em> </p><ol>
<li class="List">
In CCS, Launch the TI Debugger (Target &gt; Launch TI Debugger)  </li>
<li class="List">
Connect the debug target to the appropriate chip </li>
<li class="List">
Suspend the chip  </li>
<li class="List">
Run Scripts &gt; DLLView -Load Pro Tools Plug-In Symbols. <dl class="section note"><dt>Note</dt><dd>This script can take a moment to load; look at the Scripting Console to view its progress if you like </dd>
<dd>
This script may print a warning about TIShell.out not existing. This warning is benign for plug-in debugging since the TIShell symbols are not required in this case.  </dd></dl>
</li>
</ol>
</div><div class="section">This will load symbols for all symbol-rich modules running on the chip(s) connected to the debugger. If you load or unload plug-ins after this, you can simply repeat the "DLLView -Load Pro Tools Plug-In Symbols" command, which will synchronize the debugger with the current configuration.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>When running a plug-in in Pro Tools, the first DSP chip is reserved for the HDX mixer. Therefore the first available DSP chip for plug-in instantiation is <code>C672x_1</code>. Under DSH, the first available DSP chip is <code>C672x_0</code>.</dd></dl>
</div><h3><a class="anchor" id="subsubsection__breaking_on_first_entry_into_algorithm_"></a>
Breaking on first entry into algorithm</h3>
<div class="section"> To break on the first entry into the plug-in's processing routine, use the manual single-buffer processing mode in DSH: </p><div class="TextInd1"> <code>piproctrigger manual</code> </div> <div class="TextInd1"> <code>run&lt;index&gt; </code></div> <div class="TextInd2"> Attach debugger, suspend the chip, load symbols, set breakpoint, resume </div> <div class="TextInd1"> <code>piproctrigger auto </code></div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__breaking_on_algorithm_initialization"></a>
Breaking in the on-chip algorithm initialization callback</h3>
<div class="section"> It is not currently possible to hit a breakpoint in the optional on-chip algorithm initialization callback for a plug-in. If you need to troubleshoot this callback then you should use tracing to print debug information to a log file.</div><div class="section"></div><h2><a class="anchor" id="subsection__tracing"></a>
Tracing</h2>
<div class="section">Avid's AAX DSP platforms provide tracing functionality based on Avid's <a class="el" href="a00364.html">DigiTrace</a> tool.</div><div class="section">To enable trace logging for TI plug-ins, use the <a class="el" href="a00158.html#ab53f1d6a94f8b6ebb3a101f71bfe4e82">AAX_TRACE</a> or <a class="el" href="a00158.html#ac2aa820ece56bb59140ad561218db4b3">AAX_TRACE_RELEASE</a> macros defined in <code><a class="el" href="a00158.html" title="Declarations for cross-platform AAX_ASSERT, AAX_TRACE and related facilities. ">AAX_Assert.h</a></code>. A separate macro, <a class="el" href="a00158.html#a168ee44fd7a5485ab50160db36fb2988">AAX_ASSERT</a>, is also available for conditional tracing. These macros are cross-platform and will function whether the algorithm is running on the TI or on the host.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__tracing_requirements_"></a>
Tracing requirements</h3>
<div class="section"><ul>
<li class="Bullet">
The <a class="el" href="a00158.html#a168ee44fd7a5485ab50160db36fb2988">AAX_ASSERT</a> and <a class="el" href="a00158.html#ab53f1d6a94f8b6ebb3a101f71bfe4e82">AAX_TRACE</a> macros are debug-only and will not provide tracing output from release builds of your plug-in. <a class="el" href="a00158.html#ac2aa820ece56bb59140ad561218db4b3">AAX_TRACE_RELEASE</a> may be used for tracing in both debug and release configurations.  </li>
<li class="Bullet">
These macros require that the <code>DTF_AAXPLUGINS</code> facility is enabled in the DigiTrace configuration file. You can toggle this facility to enable or disable AAX algorithm-level tracing.  </li>
<li class="Bullet">
In order for tracing to be successful on TI platforms, your plug-in's ELF DLL must dynamically link against TIShell.out, a component that is installed alongside the Pro Tools application. This file includes the 'glue' that is required in order for the linker to resolve the DigiTrace entrypoint symbol in the DLL.  </li>
</ul>
</div><div class="section">To link your plug-in project to TIShell.out in Code Composer Studio, follow the steps listed in <a class="el" href="a00362.html#subsubsection__linking_to_tishellout_">Linking to TIShell.out</a> .</div><div class="section"></div><h3><a class="anchor" id="subsubsection__tracing_example_"></a>
Tracing example</h3>
<div class="section"></div><div class="section"><div class="fragment"><div class="line">int32_t</div>
<div class="line"><a class="code" href="a00149.html#aaa22112139aa627574b1ef562f579d43">AAX_CALLBACK</a></div>
<div class="line">MyExamplePlugIn_AlgorithmInit ( SExample_Alg_Context <span class="keyword">const</span> *</div>
<div class="line">     inInstance , <a class="code" href="a00206.html#aff5646376a3c93f032cf2400e0885023">AAX_EComponentInstanceInitAction</a> inAction )</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="a00158.html#ac2aa820ece56bb59140ad561218db4b3">AAX_TRACE_RELEASE</a> (</div>
<div class="line">      <a class="code" href="a00158.html#a8a6953f26f36747357d5d95f96dcf68d">kAAX_Trace_Priority_Normal</a> ,</div>
<div class="line">      <span class="stringliteral">&quot;MyExamplePlugIn_AlgorithmInit called for action : %d&quot;</span>,</div>
<div class="line">      inAction );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 2: Adding trace code on TI</div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__usage_notes_"></a>
Usage notes</h3>
<div class="section"><ul>
<li class="Bullet">
When running on the DSP, the actual handling of each tracing call occurs in a separate thread. This can lead to incorrect data reporting if volatile data, such as a pointer to an audio sample, is passed in to the tracing statement as a parameter.  </li>
<li class="Bullet">
DSP tracing is most reliable when using debug TI builds and when all TI compiler optimizations have been disabled  </li>
<li class="Bullet">
Known and resolved issues with DSP tracing are logged on the <a class="el" href="a00374.html">Known Issues</a> page  </li>
</ul>
</div><div class="section"></div><h2><a class="anchor" id="subsection__testing_in_pro_tools"></a>
Testing in Pro Tools</h2>
<div class="section"> </div><h3><a class="anchor" id="subsubsection__the_system_usage_window_"></a>
The System Usage window</h3>
<div class="section"> The System Usage window in Pro Tools includes some features specifically targeted at testing DSP plug-ins, and particularly for testing shuffle events. Starting in Pro Tools 10, the System Usage window includes the following test features: </p><ul>
<li class="Bullet">
Shift + Drag DSP Meter - This shuffles everything on the chosen chip to another chip, which allows you to quickly test shuffle for a given chip.  </li>
<li class="Bullet">
Hover mouse over DSP - Presents a tooltip to show the running plug-ins on a chip  </li>
<li class="Bullet">
Cmd+Option+Shift Hover - Detailed debugging tooltip info  </li>
<li class="Bullet">
Cmd+Option+Shift Click - Forces a full shuffle of all chips / cards </li>
<li class="Bullet">
Click on empty chip - Reserves a DSP to prevent allocation on that chip </li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__dsp_information_tooltip_"></a>
DSP information tooltip</h3>
<div class="section"> Pro Tools can display additional information for DSP plug-ins using some debug tooltips that are hidden in the plug-in window header and the System Usage window.</div><div class="section">The tooltip in the plug-in window header displays information about the particular plug-in instance that is currently shown in the window. To display this tooltip, hold Command-Option-Shift (Mac) or Control-Alt-Shift (Windows) and hover the mouse cursor over the DSP &gt; Native button in the plug-in header.</div><div class="section">The tooltip in the System Usage window displays usage information for each DSP chip in the system. You can reveal this tooltip for a particular chip by mousing over the chip's usage meter while holding Command-Option-Shift (Mac) or Control-Alt-Shift (Windows). This tooltip shows the chip's total allocated cycles, internal, and external memory.</div><div class="section">The information in these tooltips is generally targeted at systems-level debugging, but can prove useful for some plug-in troubleshooting as well.</div><div class="section"><div class="image">
<img src="TI_Development_Tools_PlugInHeaderDSPTooltip.png"  width="40%" alt="DSP tooltip in the Pro Tools plug-in window header"/>
</div>
 <div class="imagecaption"> Figure 1: DSP tooltip in the Pro Tools plug-in window header. </div></div><div class="section"><div class="image">
<img src="TI_Development_Tools_SystemUsageDSPTooltip.png"  width="40%" alt="DSP tooltip in the System Usage window"/>
</div>
 <div class="imagecaption"> Figure 2: DSP tooltip in the Pro Tools System Usage window. </div></div><div class="section"></div><div class="section"> </div><h1><a class="anchor" id="aax_ti_guide_05_common_issues_with_ti_development"></a>
Common Issues with TI Development</h1>
<div class="section"> </div><h2><a class="anchor" id="subsection__data_structure_compatibility"></a>
Data structure compatibility</h2>
<div class="section">AAX DSP plug-ins use a set of custom data structures to exchange information with host. In order to preserve a consistent binary interface between the plug-in's host and algorithm, the layout of these structures must be identical on both platforms. Each structure must have the same size when compiled by both the host platform compiler and the TI DSP compiler, and any members that are referenced by both the host code and the DSP code must reside at the same offset within the struct on both platforms.</div><div class="section">In order to satisfy this requirement, it is essential that an AAX plug-in's algorithm context structure and any other data structures that are passed between the host and the DSP use appropriate alignment. Data structures are usually aligned to 32-bit boundaries, and both Intel and TI compilers use identical struct alignment and packing for most cases. However, this behavior is not explicitly defined in the C standard.</div><div class="section">Furthermore, different compilers may use different sizes for some built-in data types. It is therefore very important to use explicitly-sized types such as <code>int32_t</code> and <code>float</code> rather than ambiguous types such as <code>bool</code> or <code>int</code>. One particularly tricky data type is pointers, which may be compiled as 64-bit values on a 64-bit Intel system but as 32-bit values on the TI DSP.</div><div class="section">Here are some specific scenarios when an unexpected difference in alignment or data type size may occur and cause an ABI incompatibility between a plug-in's host and DSP components:</div><div class="section"><ul>
<li class="Bullet">
<a class="el" href="a00362.html#subsubsection__nested_structures">Nested structures</a>  </li>
<li class="Bullet">
<a class="el" href="a00362.html#subsubsection__pragma_pack">Usage of pragma pack</a>  </li>
<li class="Bullet">
<a class="el" href="a00362.html#subsubsection__dynamic_allocation_of_memory">Dynamic allocation of memory in structures and algorithm</a>  </li>
<li class="Bullet">
<a class="el" href="a00362.html#subsubsection__incorrect_use_of_pointer_data">Incorrect use of pointer data</a>  </li>
<li class="Bullet">
<a class="el" href="a00362.html#subsubsection__pointer_data_size_incompatibility">Pointer data size incompatibility</a>  </li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__nested_structures"></a>
Nested structures</h3>
<div class="section">It can be particularly difficult to debug alignment issues in nested data structures. One reason is that nested structs do not necessarily have the same alignment as the parent struct. A nested structure will have the alignment that is set preceding its declaration, not the alignment of the structure in which it is contained.</div><div class="section">Aside from avoiding nested structs entirely, one way to avoid potential issues is to make sure that nested structs always contain a double. This will guarantee that the structure is double-word aligned. We have also found that placing nested structs near the beginning of the parent struct results in more consistent alignment between Intel and TI compilers, even in cases where the actual alignment of each member is strictly ambiguous according to the standard.</div><div class="section">Another important rule of thumb with nested structs is to define them inline in the enclosing structure. We have found that including one data structure as a member in another data structure will only be reliably aligned between Visual Studio and the TI compiler tools if the member structure's type is defined in-line. This does not appear to be an issue between clang and the TI compiler - the data structure alignment for the nested structure is consistent between those two compilers regardless of the location of the internal structure's definition.</div><div class="section"><div class="fragment"><div class="line"><span class="preprocessor">#include AAX_ALIGN_FILE_ALG</span></div>
<div class="line"><span class="keyword">struct </span>SomeStruct</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">float</span> a;</div>
<div class="line">   <span class="keywordtype">float</span> b;</div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#include AAX_ALIGN_FILE_RESET</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Somewhere else...</span></div>
<div class="line"><span class="preprocessor">#include AAX_ALIGN_FILE_ALG</span></div>
<div class="line"><span class="keyword">class </span>SomeClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   SomeStruct s; <span class="comment">// Don&#39;t do this! Inconsistent between Visual Studio and TI</span></div>
<div class="line"></div>
<div class="line">   <span class="comment">// other stuff...</span></div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#include AAX_ALIGN_FILE_RESET</span></div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 3: Problematic code: nested struct not defined in-line</div></div><div class="section"><div class="fragment"><div class="line"><span class="preprocessor">#include AAX_ALIGN_FILE_ALG</span></div>
<div class="line"><span class="keyword">class </span>SomeClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">   <span class="keyword">struct </span>SomeStruct</div>
<div class="line">   {</div>
<div class="line">      <span class="keywordtype">float</span> a;</div>
<div class="line">      <span class="keywordtype">float</span> b;</div>
<div class="line">   } s; <span class="comment">// This is fine - consistent between Visual Studio, clang, and TI</span></div>
<div class="line"></div>
<div class="line">   <span class="comment">// other stuff...</span></div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#include AAX_ALIGN_FILE_RESET</span></div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 4: Fixed code: nested struct defined in-line</div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__pragma_pack"></a>
Usage of pragma pack</h3>
<div class="section">If you use pragmas to align your structs, then you should know that in most cases it will only decrease the natural struct alignment of a compiler. That means that if you have</div><div class="section"><div class="fragment"><div class="line"><span class="preprocessor">#pragma pack(8)</span></div>
<div class="line"><span class="keyword">struct </span>x</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">char</span> a;</div>
<div class="line">   <span class="keywordtype">float</span> b;</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 5: Example of usage of <code>#pragma pack</code> where it has no effect</div></div><div class="section">then struct x most likely won't be aligned to the 8 byte boundary. Therefore the pack pragma is not really useful for addressing alignment issues. Instead of using pack, one way to guarantee that a structure is double-word aligned, is to include at least one double member.</div><div class="section"><div class="fragment"><div class="line"><span class="preprocessor">#pragma pack(8)</span></div>
<div class="line"><span class="keyword">struct </span>x</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">float</span> a;</div>
<div class="line">   <span class="keywordtype">double</span> b;</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 6: Example of usage of <code>#pragma pack</code> where it actually affects the alignment of the structure</div></div><div class="section">In this case data will be double-word aligned.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__dynamic_allocation_of_memory"></a>
Dynamic allocation of memory in structures and algorithm</h3>
<div class="section">The problem with dynamic allocation is that it's difficult to enforce specific alignment of the resulting block beyond the natural alignment of the structure. Newly allocated blocks are not double-word aligned by default. This prevents double-word memory access optimizations (see <a class="el" href="a00362.html#subsubsection__additional_data_type_optimizations_">Additional data type optimizations</a>) from working.</div><div class="section"><div class="fragment"><div class="line"><span class="comment">// blocks are not aligned to 8-byte boundaries by default. This prevents double-word</span></div>
<div class="line"><span class="comment">// memory access optimizations from working</span></div>
<div class="line"><span class="keywordtype">float</span>* floatBlock = <span class="keyword">new</span> <span class="keywordtype">float</span>[100];</div>
<div class="line"><span class="keyword">delete</span>[] floatBlock;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Though AAX_Alignment.h does include some aligned memory allocators to counteract the alignment</span></div>
<div class="line"><span class="comment">// problem, their use is still strongly discouraged.</span></div>
<div class="line"><span class="keywordtype">float</span>* floatBlock2 = alignMalloc&lt;float&gt;(100, 8);</div>
<div class="line"><a class="code" href="a00288.html#aa7d7e69902012a6272de3ea9aa0264a9">alignFree</a>(floatBlock2);</div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 7: Problems which may arise when using dynamic allocation of memory in algorithm</div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__incorrect_use_of_pointer_data"></a>
Incorrect use of pointer data</h3>
<div class="section">In general, you should avoid storing pointers to anything in any data structures that are passed between the host and the DSP. There are many possible problems and bugs that can be caused by this, for example:</div><div class="section"><ul>
<li class="Bullet">
Often the memory map of packets can change out from under the plug-in  </li>
<li class="Bullet">
It is easy to accidentally reference data in the wrong memory space when setting pointer values  </li>
<li class="Bullet">
Pointer data types are not explicitly sized (see <a class="el" href="a00362.html#subsubsection__pointer_data_size_incompatibility">below</a>.)  </li>
</ul>
</div><div class="section">One alternative to using raw data pointers is to store data offsets into a coefficient array rather than using direct pointers to other structure elements. A solution such as this that does not involve pointer data types will almost always end up being easier to implement, easier to troubleshoot, and easier to maintain than a solution that uses pointer data.</div><div class="section">That said, if you must use pointer data types in any data structures that are passed between the AAX host and DSP components then you should be very careful to avoid the problems listed above.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__pointer_data_size_incompatibility"></a>
Pointer data size incompatibility</h3>
<div class="section">Problems due to pointer data size incompatibility can be particularly difficult to debug. Pointer data types are not explicitly sized in C, and, starting with the 64-bit Pro Tools 11 release, pointers will have different lengths for host and TI binaries. This can cause subtle portability problems in certain circumstances, if proper care is not taken.</div><div class="section">Consider the following state block:</div><div class="section"><div class="fragment"><div class="line"><span class="keyword">struct </span>SMyPlugInStateBlock</div>
<div class="line">{</div>
<div class="line">     <span class="keywordtype">float</span> mInGain_Smoothed;</div>
<div class="line">     some_t* mPointerP;</div>
<div class="line">     <span class="keywordtype">float</span> mOutGain_Smoothed;</div>
<div class="line">};</div>
</div><!-- fragment --></div><div class="section">Notice the pointer <code>mPointerP</code> (the type that it points to is irrelevant for this discussion). Perhaps it is a pointer that can reference different sets of coefficients, or perhaps it points to some sort of global variable. In any case, this pointer is 64-bits long on the host, and 32-bits long on TI.</div><div class="section">In most cases, this won't cause a problem because the host simply allocates a bit more space for the state block than the TI needs and fills the allocated memory with 0s. But consider the case where we overload <a class="el" href="a00018.html#accef965824c9b158cafb65e59e216b6a">ResetFieldData()</a> to set <code>mOutGain_Smoothed</code> to something other than 0:</div><div class="section"><div class="fragment"><div class="line"><a class="code" href="a00149.html#a4d8f69a697df7f70c3a8e9b8ee130d2f">AAX_Result</a> MyPlugIn_Parameters::ResetFieldData (<a class="code" href="a00149.html#ae807f8986143820cfb5d6da32165c9c7">AAX_CFieldIndex</a> inFieldIndex, <span class="keywordtype">void</span> * inData, uint32_t inDataSize)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">     <a class="code" href="a00149.html#a4d8f69a697df7f70c3a8e9b8ee130d2f">AAX_Result</a> result;</div>
<div class="line">     <span class="keywordflow">switch</span> (inFieldIndex)</div>
<div class="line">     {</div>
<div class="line">        <span class="keywordflow">case</span> (eMyAlgFieldIndex_State):</div>
<div class="line">        {</div>
<div class="line">            memset(inData, 0, inDataSize);</div>
<div class="line">            SMyPlugInStateBlock* stateP = <span class="keyword">static_cast&lt;</span>SMyPlugInStateBlock*<span class="keyword">&gt;</span>(inData);</div>
<div class="line">            stateP-&gt;mOutGain_Smoothed = mOutGain_Target;</div>
<div class="line">            result = <a class="code" href="a00207.html#a5f8c7439f3a706c4f8315a9609811937aeddbd1bb67e3a66e6af54a4b4a7a57b3">AAX_SUCCESS</a>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">        {</div>
<div class="line">            result = <a class="code" href="a00018.html#accef965824c9b158cafb65e59e216b6a">AAX_CEffectParameters::ResetFieldData</a>(inFieldIndex, inData, inDataSize);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">     }</div>
<div class="line">     <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --></div><div class="section">We might be doing this if <code>mOutGain_Smoothed</code> was a smoothing parameter and we want to start it at the target gain value (rather than having it smooth from 0.0 at instantiation). But if the Host and TI can't agree on where in the state block mOutGain_Smooth is located, then the result will be unexpected behavior that is difficult to debug.</div><div class="section">The most direct way to avoid this problem is to use an explicitly-sized 32-bit type for any pointers in your state block:</div><div class="section"><div class="fragment"><div class="line"><span class="keyword">struct </span>SMyPlugInStateBlock</div>
<div class="line">{</div>
<div class="line">     <span class="keywordtype">float</span> mInGain_Smoothed;</div>
<div class="line">     uint32_t mPointerP;</div>
<div class="line">     <span class="keywordtype">float</span> mOutGain_Smoothed;</div>
<div class="line">};</div>
</div><!-- fragment --></div><div class="section">It will be necessary to use <code>reinterpret_cast&lt;float*&gt;(stateP-&gt;mPointerP)</code> to recast the pointer to a pointer data type on the TI, but that should not result in any extra processing cycles.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__alignment_reference"></a>
Alignment Reference</h3>
<div class="section">These are the data type sizes and default alignments for some common compilers when compiling for 64-bit binary formats:</div><div class="section"><table class="doxtable">
<tr>
<th></th><th colspan="2" align="CENTER">TI </th><th colspan="2" align="CENTER">MS Visual C++ </th><th colspan="2" align="CENTER">C++ Builder </th><th colspan="2" align="CENTER">GCC  </th></tr>
<tr>
<th>char </th><td align="RIGHT">1 byte </td><td align="LEFT">1-byte aligned </td><td align="RIGHT">1 byte </td><td align="LEFT">1-byte aligned </td><td align="RIGHT">1 byte </td><td align="LEFT">1-byte aligned </td><td align="RIGHT">1 byte </td><td align="LEFT">1-byte aligned  </td></tr>
<tr>
<th>short </th><td align="RIGHT">2 bytes </td><td align="LEFT">2-byte aligned </td><td align="RIGHT">2 bytes </td><td align="LEFT">2-byte aligned </td><td align="RIGHT">2 bytes </td><td align="LEFT">2-byte aligned </td><td align="RIGHT">2 bytes </td><td align="LEFT">2-byte aligned  </td></tr>
<tr>
<th>int </th><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned </td><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned </td><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned </td><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned  </td></tr>
<tr>
<th>long </th><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned  </td></tr>
<tr>
<th>long long </th><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned  </td></tr>
<tr>
<th>bool </th><td align="RIGHT">1 byte </td><td align="LEFT">1-byte aligned </td><td align="RIGHT">1 byte </td><td align="LEFT">1-byte aligned </td><td align="RIGHT">1 byte </td><td align="LEFT">1-byte aligned </td><td align="RIGHT">1 byte </td><td align="LEFT">1-byte aligned  </td></tr>
<tr>
<th>float </th><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned </td><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned </td><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned </td><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned  </td></tr>
<tr>
<th>double </th><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned  </td></tr>
<tr>
<th>long double </th><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">16 bytes </td><td align="LEFT">16-byte aligned  </td></tr>
<tr>
<th>pointer </th><td align="RIGHT">4 bytes </td><td align="LEFT">4-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned </td><td align="RIGHT">8 bytes </td><td align="LEFT">8-byte aligned  </td></tr>
</table>
</div><div class="section">Also here are some useful links to web resources on the topic: </p><ul>
<li class="Bullet">
<div class="TextInd1"> A good resource for the TI DSP is <a href="http://www.ti.com/lit/an/sprab89/sprab89.pdf" target="_top">http://www.ti.com/lit/an/sprab89/sprab89.pdf</a> (Section 2 especially). This document includes some graphs of simple alignment examples. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<div class="TextInd1"> Another good reference regarding general struct alignment issues is available from publib.boulder.ibm.com: <a href="http://publib.boulder.ibm.com/infocenter/macxhelp/v6v81/index.jsp?topic=/com.ibm.vacpp6m.doc/compiler/ref/rnpgpack.htm" target="_top">http://publib.boulder.ibm.com/infocenter/macxhelp/v6v81/index.jsp?topic=/com.ibm.vacpp6m.doc/compiler/ref/rnpgpack.htm</a> </div>  </li>
</ul>
</div><div class="section"></div><div class="section"> </div><h1><a class="anchor" id="aax_ti_guide_06_ti_optimization_guide"></a>
TI Optimization Guide</h1>
<div class="section">Optimizing AAX real-time algorithms for Avid's TI-based platforms is very similar to optimizing real-time algorithms for any architecture. When developers think about optimization, they often think "I want to make my code run faster". In reality, however, optimization is about making the processor do less. After all, the processor's clock rate is fixed and can only perform a limited number of instructions in a set amount of time. Therefore, our focus in this section will be on helping the compiler produce code with shorter execution paths and make full use of the TI chip's architecture.</div><div class="section">Modern compilers have become extremely powerful at being able to optimize code, which is fortunate given the complicated architectures of today's DSP products. In this section we will not focus on instruction-level "optimizations" like the one below, which will automatically be done by the compiler. Instead of making our code faster, which it won't, little "tricks" like this really just make code harder to read:</div><div class="section"><div class="fragment"><div class="line"><span class="keywordtype">int</span> y = x;</div>
<div class="line">y = y &gt;&gt; 1; <span class="comment">// y = y / 2; </span></div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 8: The kind of optimization that you won't be seeing in this section</div></div><div class="section">Rather, we will focus on refactoring audio processing algorithms to be more efficient and on giving the TI compiler better information about the code, pointers, and data it is working with so it can perform more effective compile-time optimizations.</div><div class="section">Finally, our optimization efforts will focus on the worst-case code path. For example, developers often try to optimize algorithms by conditionally bypassing portions of code that may be disabled by particular parameter states. This is counter-productive, because the system has to assume a plug-in's worst-case execution performance regardless of how much time the plug-in is actually using. Therefore, in the context of real-time algorithms running on AAX DSP platforms, it is best to only worry about worst-case execution time.</div><div class="section">For more information about using TI's toolset to profile your code's performance, see <a class="el" href="a00365.html#subsection__cyclessharedtest">Cycle count performance test</a>.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>The optimizations described in this section assume that you are using version 7 or higher of TI's C6000 Code Generation Tools (CGTools). We strongly recommend using v7.0.5 as earlier versions throw linking errors.</dd></dl>
</div><h2><a class="anchor" id="subsection__optimization_quick_start"></a>
Optimization quick start</h2>
<div class="section">Here is a quick outline of the general optimization steps for an AAX DSP algorithm: </p><ol>
<li class="List">
Before beginning your DSP optimizations, make sure that your Native algorithm has basic optimizations in place. In our experience, beginning the TI optimization process with a slow or needlessly precise Native algorithm will result in a long porting process. Here are some suggestions for common Native optimizations: <ul>
<li class="DashInd">
Identify unnecessary double precision  </li>
<li class="DashInd">
Identify tables that have too high of granularity  </li>
</ul>
</li>
<li class="List">
Make sure your compiler Release settings enable the compiler to optimize fully and give full optimization comments: <div class="TextInd1"> <code>-k -s -pm -op3 -os -o3 -mo -mw –consultant –verbose -mv67p</code></div>  </li>
<li class="List">
Use the load/update/store design pattern to reduce memory accesses in inner loops  </li>
<li class="List">
Move any processing that does not directly depend on the audio signal out of the real-time algorithm  </li>
<li class="List">
Declare non-changing variables and pointers (both local and in parameter lists) as <code>const</code>  </li>
<li class="List">
Declare non-aliased pointers (both local variables and function parameters) as AAX_RESTRICT  </li>
<li class="List">
Change any <code>long</code> variables to<em class="Default-Font"> </em> <code>int</code>, and change <code>double</code> variables to <code>float</code> if the reduced precision does not affect signal integrity (usually defined as cancellation with the plug-in's Native algorithm.)  </li>
<li class="List">
Restructure inner processing loops so that they do not contain large conditional statements or other branches  </li>
<li class="List">
Declare any functions that are called within the innermost processing loop as <code>inline</code> in order to allow the inner loops to pipeline  </li>
<li class="List">
Add loop count information when known, using <code>#pragma MUST_ITERATE(min,max,quant)</code> </li>
</ol>
</div><div class="section"></div><h2><a class="anchor" id="subsection__compiler_and_linker_options"></a>
Compiler and linker options</h2>
<div class="section">As with any complex environment, many performance gains on the TI rely on the appropriate compiler and linker options. The options documented here will allow CGTools to apply its optimization logic to your algorithm.</div><div class="section">When tweaking compiler options on the TI, keep in mind that, like on any CPU, it is useless to optimize Debug code or to profile its performance. This is especially true on TI processors because of the fact that generated Debug and Release assembly is almost completely different, assuming that heavy optimization options were chosen for the Release configuration.</div><div class="section">In general, all recommended compiler options should be set correctly in the AAX SDK's example plug-in projects, and these settings may be used as a guide for your own plug-in projects. See the SDK files CommonPlugIn_CompilerCmd.cmd and CommonPlugIn_LinkerCmd.cmd for the latest recommended settings.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__overview_of_optimizationrelated_compiler_options_"></a>
Overview of optimization-related compiler options</h3>
<div class="section"> <ul>
<li class="Bullet">
<p class="startli"><code>-g</code> </p><div class="TextInd1"> Full symbolic debug. This setting should be used in debug configurations to make stepping through code easier. It should not be defined in release configurations, as it will prevent the compiler from being able to fully optimize code. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-k</code> </p><div class="TextInd1"> Keep generated .asm files. This should be turned on in release configuraions so that you can use the ASM output as feedback when making optimization decisions and performance improvements. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-d"_DEBUG"</code> </p><div class="TextInd1"> Defines the <code>_DEBUG</code> preprocessor macro that alters how certain code is generated (asserts, stdlib, etc). This should be turned on in debug configurations only. Note that TI does not require NDEBUG to be defined in release configurations.</div><div class="TextInd1"><dl class="section note"><dt>Note</dt><dd>This will eventually be deprecated in favor of the pre-defined "_TMS320C6X" macro.</dd></dl>
</div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-mv67p</code> </p><div class="TextInd1"> Specifies that the compiler should build code for the C67x+ chip variant we are using, which has some improvements beyond the original C67x. This option should be enabled in all build configurations that target the HDX platform. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-s</code> </p><div class="TextInd1"> Specifies Opt-C/ASM interlisting. This interweaves modified C-code and ASM in the .ASM file produced by the <code>-k</code> option. You should use <code>-s</code> in release configurations so that the ASM file can be read more easily.</div><div class="TextInd1"><dl class="section note"><dt>Note</dt><dd>Do NOT use the <code>-ss</code> option in release configurations. This option will negatively affect optimization</dd></dl>
</div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-pm</code> </p><div class="TextInd1"> Program mode compilation. Instructs the C compiler to compile all files in the same compilation unit, so that it can optimize code further using information from all files being compiled. See <a class="el" href="a00362.html#subsubsection__program_mode_optimization_pm_">Program Mode optimization (-pm)</a> for more information. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-op3</code> </p><div class="TextInd1"> A modifier for the -pm option, this specifies that there are no external variable references in the project. This option is appropriate for TI algorithms, which do have an external function reference (the process entry point) but do not have external variable references. This option allows the compiler to further optimize global variables without worrying whether they will be accessed outside of the compilation unit. See <a class="el" href="a00362.html#subsubsection__program_mode_optimization_pm_">Program Mode optimization (-pm)</a> for more information </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-o3</code> </p><div class="TextInd1"> File-level optimization. This flag gives the compiler full ability to optimize C-code by reordering instructions, inlining functions, and performing other optimizations. Note that the resulting ASM code will be very difficult to parse back into the original C and will make debugging very difficult, so this flag should only be used for Release code. See <a class="el" href="a00362.html#subsubsection__optimization_flags_o_">Optimization flags (-o)</a> for more information. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-mo</code> </p><div class="TextInd1"> Use Function Subsections. This instructs the compiler to place all functions into their own separate subsection in the linker map. This allows the linker to remove unused functions in order to reduce memory usage. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-mw</code> </p><div class="TextInd1"> Generate a single iteration view of SP loops. This flag adds important information to the ASM output file that is useful when optimizing your code for pipelined loops. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>–verbose</code> </p><div class="TextInd1"> Output verbose status messages when compiling files. Though not very useful for humans, verbose output will produce some key information that text parsers can use, such as compiler versions and other details. </div> <p class="endli"></p>
</li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__overview_of_optimizationrelated_linker_options_"></a>
Overview of optimization-related linker options</h3>
<div class="section"> <ul>
<li class="Bullet">
<p class="startli"><code>–relocatable</code> </p><div class="TextInd1"> Generate a relocatable non-executable. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-m"file.map"</code> </p><div class="TextInd1"> Generate a map file. This file contains useful information about the memory footprint of your plug-in, which is useful for fixing large plug-ins that may not have fit into available program memory. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-w</code> </p><div class="TextInd1"> Warn about output sections. This flag generates very useful information that tells you if there might be a problem with memory output sections you are trying to generate. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-x</code> </p><div class="TextInd1"> Exhaustively read libraries. This is a useful flag if you do not want to worry about the order in which you specify required libraries. </div> <p class="endli"></p>
</li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__optimization_flags_o_"></a>
Optimization flags (-o)</h3>
<div class="section"> <ul>
<li class="Bullet">
<p class="startli">Register (<code>-o0</code>) </p><div class="TextInd1"> This option allows for some performance gains over non-optimized code by allocating variables to registers, inlining functions declared inline, etc. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli">Local (<code>-o1</code>) </p><div class="TextInd1"> This option enables local optimizations, with very similar results to the register-level optimizations of -o0. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli">Function (<code>-o2</code>) </p><div class="TextInd1"> This is the standard optimization level, and provides large gains over unoptimized code. This optimization level allows function-level optimizations such as software pipelining, loop optimization/unrolling, etc. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli">File (-<code>o3</code>) </p><div class="TextInd1"> This option can provide some speedup beyond function-level optimizations, but also mutilates assembly code beyond recognition. At this optimization level the compiler will remove unused functions, simplify code in the case of unused return values, auto-inline small functions, etc. </div> <p class="endli"></p>
</li>
</ul>
</div><div class="section">Like the corresponding Visual Studio options,<code>-o0</code> and <code>-o1</code> allow you to step through code line-by-line for debugging, at the cost of reduced performance. <code>-o2</code> and <code>-o3</code> sacrifice the ability to step through code and watch memory in favor of optimized code.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__program_mode_optimization_pm_"></a>
Program Mode optimization (-pm)</h3>
<div class="section"> Program mode optimization gives the compiler further optimization information by compiling all files at once rather than individually. Thus global constants, function implementations, etc. can be made known to the entire program at compilation. This allows the compiler to inline functions more effectively and to determine loop unrolling based on constant loop iterators.</div><div class="section">There are a few <code>-pm</code> options:</div><div class="section"><ul>
<li class="Bullet">
<p class="startli"><code>-pm -op0</code> </p><div class="TextInd1"> Contains functions and variables that are called or modified from outside the source code provided to the compiler. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-pm -op1</code> </p><div class="TextInd1"> Contains variables modified from outside the source code provided to the compiler but does not use functions called from outside the source code. </div><div class="TextInd1"> <em class="Italic"> This option is not appropriate for AAX plug-in algorithms, because the algorithm component will be exported and called from outside the compiled source code.</em> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-pm -op2</code> </p><div class="TextInd1"> Contains no functions or variables that are called or modified from outside the source code provided to the compiler. </div><div class="TextInd1"> <em class="Italic"> This option is not appropriate for AAX plug-in algorithms, because the algorithm component will be exported and called from outside the compiled source code.</em> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-pm -op3</code> </p><div class="TextInd1"> Contains functions that are called from outside the source code provided to the compiler but does not use variables modified from outside the source code. </div> <div class="TextInd1"> This is the recommended Program Mode optimization level for TI plug-ins. This optimization level requires that no global variables are used outside of the algorithm callback. In general, any such variables should be passed in to a TI algorithm via the algorithm's context structure. </div> </li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__compiler_options_to_avoid_"></a>
Compiler options to avoid</h3>
<div class="section"> The following information was taken from the TMS320C6000 Programmer's Guide:</div><div class="section"><ul>
<li class="Bullet">
<p class="startli"><code>-g/-s/-ss</code> </p><div class="TextInd1"> These options limit the amount of optimization across C statements, leading to larger code size and slower program execution. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-mu</code> </p><div class="TextInd1"> This option disables software pipelining for debugging. If a reduction in code size is necessary, use the <code>-ms2</code>/<code>-ms3</code> options. These options will disable software pipelining among their other code size optimizations. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>-mz</code> </p><div class="TextInd1"> This option is obsolete. When using 3.00+ compilers, this option will decrease performance and increase code size. </div> <p class="endli"></p>
</li>
</ul>
</div><div class="section"></div><h2><a class="anchor" id="subsection__the_loadupdatestore_pattern"></a>
The load-update-store pattern</h2>
<div class="section"> The load-update-store pattern is one of the cornerstones of a fast iterative algorithm. This pattern specifies that locally accessed data should be loaded into memory at the start of processing, accessed during processing, and stored or saved after processing has completed. By using this pattern you will move memory reads and writes outside of your plug-in's innermost processing loop, which reduces data dependencies and shortens the critical inner loop.</div><div class="section">As an example, consider the following unoptimized filter code:</div><div class="section"><div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span></div>
<div class="line">ProcessDirectFormII(<span class="keywordtype">float</span>* input, <span class="keywordtype">float</span>* output, <span class="keywordtype">float</span>* state, <span class="keywordtype">float</span>*</div>
<div class="line">    coefs, <span class="keywordtype">int</span> nsamp)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// eB0 .. eB2 and eA0, eA1 are just integer enums to partition</span></div>
<div class="line">    <span class="comment">// the filter coefficients into A and B</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nsamp; ++i)</div>
<div class="line">    {</div>
<div class="line">        output[i] = input[i]*coefs[eB0] + state[0];</div>
<div class="line">        state[0] = input[i]*coefs[eB1] + state[1] - output[i]*coefs[eA0];</div>
<div class="line">        state[1] = input[i]*coefs[eB2] - output[i]*coefs[eA1];</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 9: Unoptimized filter algorithm</div></div><div class="section">Notice that in this code there are at least 15 memory accesses per loop iteration! This algorithm will be very inefficient as the value of <code>nsamp</code> increases.</div><div class="section">The compiler should be able to optimize this algorithm to some extent by pulling certain memory accesses outside of the loop. However, the compiler cannot completely optimize the loop because it must assume that the input/output/state/coefs pointers are aliased in memory. We will discuss the <code>const</code> and <code>restrict</code> keywords later, which are ways to give the compiler additional information it can use to optimize this loop. However, for now let's focus back on the basic design of this code.</div><div class="section">Using load-update-store, we can refactor this loop to pull the memory accesses outside of the loop:</div><div class="section"><div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">ProcessDirectFormII (<span class="keywordtype">float</span>* input, <span class="keywordtype">float</span>* output, <span class="keywordtype">float</span>* state, <span class="keywordtype">float</span> *</div>
<div class="line">    coefs, <span class="keywordtype">int</span> nsamp)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// eB0 .. eB2 and eA0, eA1 are just integer enums to partition</span></div>
<div class="line">    <span class="comment">// the filter coefficients into A and B</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// ---- LOAD ----</span></div>
<div class="line">    <span class="keywordtype">float</span> coefA0 = coefs [eA0];</div>
<div class="line">    <span class="keywordtype">float</span> coefA1 = coefs [eA1];</div>
<div class="line">    <span class="keywordtype">float</span> coefB0 = coefs [eB0];</div>
<div class="line">    <span class="keywordtype">float</span> coefB1 = coefs [eB1];</div>
<div class="line">    <span class="keywordtype">float</span> coefB2 = coefs [eB2];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> state0 = state [0];</div>
<div class="line">    <span class="keywordtype">float</span> state1 = state [1];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> output;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// ---- UPDATE ----</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nsamp; ++i)</div>
<div class="line">    {</div>
<div class="line">        output = input [i]* coefB0 + state0;</div>
<div class="line">        state0 = input [i]* coefB1 + state1 - output * coefA0;</div>
<div class="line">        state1 = input [i]* coefB2 - output * coefA1;</div>
<div class="line">        output [i] = output;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// ---- STORE ----</span></div>
<div class="line">    state [0] = state0;</div>
<div class="line">    state [1] = state1;</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 10: Refactored filter algorithm with load-update-store pattern applied. Not fully optimized.</div></div><div class="section">Though the code initially appears longer, you will notice that we have reduced the loop to only 4 memory accesses! Though we have an additional 9 memory accesses outside the loop, they will only occur once per function call, resulting in significant savings at higher values of <code>nsamp</code>.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>we are not finished with this loop yet, because we can make some very significant gains by using the <code>restrict</code> and <code>const</code> keywords, as discussed in the section on <a class="el" href="a00362.html#subsection__c_keywords">C keywords</a>.</dd></dl>
<p>Before moving on from load-update-store, let's consider how this pattern should be applied to different categories of data that may be provided in an AAX DSP processing context:</div><div class="section"><ul>
<li class="Bullet">
<p class="startli">Coefficients and parameters </p><div class="TextInd1"> Coefficients and parameters are read-only by definition. As such, they should be loaded into a local variable at the beginning of the algorithm callback and should not be modified further. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli">Private state </p><div class="TextInd1"> State parameters are writable and may be changed by the algorithm. Therefore, private state data should be loaded into a local variable copy, then stored back into memory after the local copy is updated. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli">Output </p><div class="TextInd1"> Output is write-only, so all calculations may be performed on a local variable and then stored into memory once per loop. </div> <p class="endli"></p>
</li>
</ul>
</div><div class="section"></div><h2><a class="anchor" id="subsection__case_study_iir_filter_implemenation_on_ti_672x_dsps"></a>
Case study: IIR filter implemenation on TI 672x DSPs</h2>
<div class="section"> In this section we will examine various IIR filter implementations as a specific example of the considerations that must be made when optimizing DSP code for the 672x.</div><div class="section">The TI 67xx family of DSPs is notably different from some other typical DSP processors, such as the 56k and the Intel FPU, in that the TI DSP does not have an implicit higher-precision multiply-accumulate. It is of course capable of double precision accumulation, but this must be coded explicitly. In some ways, this is similar to the Intel SSE processing unit, which jetisonned the 80-bit floating point stack used in the Intel FPU. The lack of higher precision accumulation in TI (and SSE) can sometimes result in unacceptable quantization noise performance for single precision filter implementations. Luckily, with the right choice of filter structure or coding for explicit double precision accumulation, excellent results can be achieved.</div><div class="section">On fixed-point DSPs such as 56k, Direct Form I (DF1) implementation is the standard due to moderately good fixed point scaling properties, decent noise performance, and simple implementation. However, on a 672x DSP a single precision DF1 filter can have terrible noise performance (depending on the filter coefficients and the audio material being processed.) A degenerate case is a DF1 highpass filter processing low frequency material; in DF1, the feedforward coefficients subtract the previous sample from the current sample, and for low frequency material this produces very small numbers with low precision. Single precision DF2 structures also produce similarly poor results in this respect.</div><div class="section">One option to improve upon these results is to use double precision throughout the 672x filter implementation. However, this results in a heavy cycle performance penalty due to the high cost of double operations on the TI DSP. Another, often better, option is to use single precision coefficients and state, with double precision accumulation:</div><div class="section"><div class="fragment"><div class="line"><span class="keywordtype">float</span> in, b0, b1, a1, state1;</div>
<div class="line"><span class="keywordtype">double</span> accum ;</div>
<div class="line">accum = double (b0) * double (in) +</div>
<div class="line">        double (b1) * double (state1) +</div>
<div class="line">        double (a1) * double (accum);</div>
<div class="line">state1 = in; </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 11: Mixed-precision DF1 filter implementation</div></div><div class="section">The TI compiler will implement this using the mpysp2dp instruction, since it knows that the operands started out as single precision and end up as double precision. This is considerably faster than going to a full double precision implementation, but it is still relatively slow compared to straight single precision. Making the state double precision will improve noise performance further, with some increase in cycle usage.</div><div class="section">Another option that generally gets good results is the single precision DF2 Transpose (DF2T) filter. On TI the DF2T implementation is fast and generally has good noise performance. If you are looking for a simple recommendation that should work well enough for most applications, DF2T is a good choice.</div><div class="section">The optimized C filter library available from TI uses the DF2 structure in its implementation. Even though DF2 has some limitations, this is a good starting point for seeing how to optimize filter code on TI; peak performance on TI is 2.25 cycles per biquad, so it's pretty amazing what can be done (to achieve that level of performance multiple series or parallel biquads need be put in a tight loop.) We have adapted some of this filter code to DF2T, and still achieved fairly similar cycle performance.</div><div class="section">If the single precision DF2T noise performance is not good enough for your application, then either double precision or one of the myriad other filter structures, such as State Space, Gold-Rader, Lattice or Zolzer, should do the job. In fact, there is one relatively new filter structure which we think stands out, called the Direct Wave Form (DWF) filter. Details about this filter structure can be found in <em class="Italic"> Direct Wave Form Digital Filter Structure: an Easy Alternative for the Direct Form</em> by Jean H.F. Ritzerfel. According to the author the noise performance is 3dB within optimal, it's relatively efficient (5 multiplies per biquad), free of limit cycles, has simple coefficient generation and low coefficient quantization sensitivity. It might just be the perfect filter structure, but we'll let you be the judge of that; keep in mind that all filter structures have some tradeoffs, and the recommendations made here might not be the best for your particular application.</div><div class="section"></div><h2><a class="anchor" id="subsection__understanding_cgtoolsgenerated_asm_files"></a>
Understanding CGTools-generated ASM files</h2>
<div class="section"> The ability to read the ASM files that are generated by CGTools is essential when optimizing a TI algorithm. Specifically, the information in these files will allow you to determine if anything is preventing software pipelining from occurring, which is the single most effective form of optimization on the C6727.</div><div class="section">To view your project's ASM file, turn on the <code>-k</code> compiler option ("Keep Generated .asm Files", found under Build Options &gt; Compiler &gt; Assembly in the Code Composer Studio IDE.) By default, ASM files will be placed in the same directory as the corresponding source file.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>You should only examine ASM listings of Release code that has been optimized by the compiler. Debug code should not be optimized.</dd></dl>
<p>Each ASM file for a TI algorithm callback should contain text that marks the start of the assembly listing for the processing loop. For example:</div><div class="section"><div class="fragment"><div class="line">;**********************************************************************</div>
<div class="line">;* FUNCTION NAME: <span class="comment">// [Your algorithm&#39;s ProcessProc symbol] ___________*</span></div>
<div class="line">;*____________________________________________________________________*</div>
<div class="line">;* Regs Modified: A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14, _*</div>
<div class="line">;*________________A15,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12, _____*</div>
<div class="line">;* _______________B13,SP,A16,A17,A18,A19,A20,A21,A22,A23,A24,A25, ____*</div>
<div class="line">;*________________A26,A27,A28,A29,A30,A31,B16,B17,B18,B19,B20,B21, ___*</div>
<div class="line">;* _______________B22,B23,B24,B25,B26,B27,B28,B29,B30, B31 ___________*</div>
<div class="line">;* Regs Used____: A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14, _*</div>
<div class="line">;* _______________A15,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12, _____*</div>
<div class="line">;* _______________B13,DP,SP,A16,A17,A18,A19,A20,A21,A22,A23,A24, _____*</div>
<div class="line">;* _______________A25,A26,A27,A28,A29,A30,A31,B16,B17,B18,B19,B20, ___*</div>
<div class="line">;* _______________B21,B22,B23,B24,B25,B26,B27,B28,B29,B30,B31 ________*</div>
<div class="line">;* Local Frame Size: 0 Args + 148 Auto + 44 Save = 192 byte __________*</div>
<div class="line">;********************************************************************** </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 12: CGTools-generated header for a processing loop assembly listing</div></div><div class="section">Within this listing, you are looking for several things: </p><ol>
<li class="List">
Function calls  </li>
<li class="List">
Branches or control code  </li>
<li class="List">
Software pipelining notes  </li>
</ol>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__function_calls_"></a>
Function calls</h3>
<div class="section"></div><div class="section"><div class="fragment"><div class="line">   [!B0]  CALL  .S1   __divd         ; |213|</div>
<div class="line">|| [!B0]  MVKH  .S2   0x40080000 ,B5 ; |213|</div>
<div class="line">|| [ B0]  MV    .L1X  B10 ,A4        ; |213|</div>
<div class="line">$C$RL9 : ; CALL OCCURS {__divd}      ; |213| </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 13: Function call in a CGTools-generated assembly listing</div></div><div class="section">Function calls, such as the call in the listing above, cannot be effectively pipelined. If you find a function call figure out what C instruction it is caused by. Sometimes a function call will be made implicitly, such as when casting from float to int or when doing division. All function calls should be removed from the processing loop or inlined in order for the compiler to optimize effectively.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__branches_"></a>
Branches</h3>
<div class="section"></div><div class="section"><div class="fragment"><div class="line">    NOP          1</div>
<div class="line">    B     .S1    $C$L5                 ; |213|</div>
<div class="line">    NOP          4</div>
<div class="line">    MPYDP .M1X   A5:A4 ,B5:B4 ,A11:A10 ; |213|</div>
<div class="line">||  LDW   .D2T2  *+ SP (124) ,B5       ; |218|</div>
<div class="line">    ; BRANCH OCCURS { $C$L5 }          ; |213| </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 14: Branch in a CGTools-generated assembly listing</div></div><div class="section">Branches can also prevent loop pipelining. If you find a branch in your algorithm's assembly, determine whether it is preventing the compiler from pipelining a loop. If it is preventing pipelining, you must figure out how to rewrite the conditional in your C code so that it will not be compiled into a branch.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__software_pipelining_notes_"></a>
Software pipelining notes</h3>
<div class="section"> For each loop the compiler finds and is able to pipeline, the .ASM file should contain a section similar to the one below:</div><div class="section">&#160;</div><div class="section"><div class="fragment"><div class="line">;*--------------------------------------------------------------------*</div>
<div class="line">;* SOFTWARE PIPELINE INFORMATION</div>
<div class="line">;*</div>
<div class="line">;* Loop source line : 68</div>
<div class="line">;* Loop opening brace source line : 69</div>
<div class="line">;* Loop closing brace source line : 124</div>
<div class="line">;* Loop Unroll Multiple : 2x</div>
<div class="line">;* Known Minimum Trip Count : 1</div>
<div class="line">;* Known <a class="code" href="a00288.html#a55ac62cf1b543338c58f8dd0d747c56c">Max</a> Trip Count Factor : 1</div>
<div class="line">;* Loop Carried Dependency Bound (^) : 15</div>
<div class="line">;* Unpartitioned Resource Bound : 20</div>
<div class="line">;* Partitioned Resource Bound (*) : 20</div>
<div class="line">;* Resource Partition :</div>
<div class="line">;* A- side B- side</div>
<div class="line">;* .L units 0 0</div>
<div class="line">;* .S units 0 1</div>
<div class="line">;* .D units 20* 20*</div>
<div class="line">;* .M units 7 5</div>
<div class="line">;* .X cross paths 5 6</div>
<div class="line">;* .T address paths 20* 20*</div>
<div class="line">;* Long read paths 5 1</div>
<div class="line">;* Long write paths 0 0</div>
<div class="line">;* Logical ops (. LS) 5 4 (.L or .S unit )</div>
<div class="line">;* Addition ops (. LSD) 0 1 (.L or .S or .D unit )</div>
<div class="line">;* Bound (.L .S .LS) 3 3</div>
<div class="line">;* Bound (.L .S .D .LS .LSD) 9 9</div>
<div class="line">;*</div>
<div class="line">;* Searching <span class="keywordflow">for</span> software pipeline schedule at ...</div>
<div class="line">;* ii = 20 Schedule found with 3 iterations in parallel </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 15: Pipelined loop header in a CGTools-generated assembly listing</div></div><div class="section">These are the important items to note in this listing:</div><div class="section"><ul>
<li class="Bullet">
<p class="startli"><code>Loop Carried Dependency Bound</code> and <code>Partitioned Resource Bound</code> </p><div class="TextInd1"> The maximum of these numbers is the minimum number of clock cycles one instance of the loop will require in its current form. You can reduce these numbers by performing some of the optimizations listed in this guide. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>Loop Unroll Multiple</code> </p><div class="TextInd1"> This line will appear if the compiler is partially unrolling the loop to improve performance. </div> <p class="endli"></p>
</li>
</ul>
</div><div class="section">If a loop section instead displays <code>Disqualified loop</code>: then some of the conditions required to enable software pipelining have not been met:</div><div class="section"><ul>
<li class="Bullet">
<code>-o2</code> or -<code>o3</code> optimizations must be enabled  </li>
<li class="Bullet">
The loop cannot contain a function call. Make all called functions inline.  </li>
<li class="Bullet">
The loop cannot contain any branches or jumps, often caused by large conditional statements  </li>
<li class="Bullet">
Software pipelining will not work with nested loops; only the innermost loop will be pipelined. You should completely unroll the inner loop or refactor the algorithm so that the loop can be pipelined  </li>
</ul>
</div><div class="section">For more information about pipelining and loop/branch optimization, see <a class="el" href="a00362.html#subsection__refactoring_conditionals_and_branches">Refactoring conditionals and branches</a>.</div><div class="section"></div><h2><a class="anchor" id="subsection__c_keywords"></a>
C keywords</h2>
<div class="section">There are a few keywords in C that give the compiler additional information about the variables you declare and parameters you pass into functions. This allows the compiler to further optimize the code it is compiling, which can result in significant performance gains.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__const_"></a>
const</h3>
<div class="section"> Effective use of <code>const</code> lets the compiler know whether pointers, scalars, or objects will remain constant in memory.</div><div class="section">Let's add the <code>const</code> keyword to the filter function from our example of <a class="el" href="a00362.html#subsection__the_loadupdatestore_pattern">The load-update-store pattern</a>.</div><div class="section"><div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">ProcessDirectFormII (</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> * <span class="keyword">const</span> input, <span class="comment">// read - only</span></div>
<div class="line">    <span class="keywordtype">float</span> * <span class="keyword">const</span> output, <span class="comment">// read - write</span></div>
<div class="line">    <span class="keywordtype">float</span> * <span class="keyword">const</span> state, <span class="comment">// read - write</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> * <span class="keyword">const</span> coefs , <span class="comment">// read - only</span></div>
<div class="line">    <span class="keywordtype">int</span> nsamp )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// eB0 .. eB2 and eA0, eA1 are just integer enums to partition</span></div>
<div class="line">    <span class="comment">// the filter coefficients into A and B</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// ---- LOAD ----</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefA0 = coefs [ eA0 ];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefA1 = coefs [ eA1 ];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefB0 = coefs [ eB0 ];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefB1 = coefs [ eB1 ];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefB2 = coefs [ eB2 ];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> state0 = state [0];</div>
<div class="line">    <span class="keywordtype">float</span> state1 = state [1];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// ---- UPDATE ----</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i =0; i&amp;lt; nsamp; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> output = input [i]* coefB0 + state0 ;</div>
<div class="line">        state0 = input [i]* coefB1 + state1 - output * coefA0 ;</div>
<div class="line">        state1 = input [i]* coefB2 - output * coefA1;</div>
<div class="line">        output [i] = output;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// ---- STORE ----</span></div>
<div class="line">    state [0] = state0;</div>
<div class="line">    state [1] = state1;</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 16: Refactored filter algorithm with load-update-store pattern and const keyword applied. </div></div><div class="section">It is especially important to note that the declaration of <code>const float output</code> was moved inside the loop. Why did we do this? Because we see that output is constant over an iteration of the loop, but it does change between iterations. By declaring it <code>const</code> inside the loop body we remove the data dependency that existed in output and allow the loop to optimize more effectively.</div><div class="section">As demonstrated by this change to <code>const float output</code>, <code>const</code> is useful for manually breaking dependencies in DSP code. Variable re-use introduces unnecessary data dependencies in code, which can be avoided by using individual local const variables.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__restrict_"></a>
restrict</h3>
<div class="section"> The <code>restrict</code> keyword tells the compiler that a specific pointer is not aliased, meaning that none of the memory locations accessed by the pointer are read or written to by any other variable within its local scope. This keyword is very important when optimizing TI code that involves pointers, as all AAX algorithms do due to the nature of the algorithm context structure.</div><div class="section"><code>restrict</code> was introduced with the C99 standard. AAX plug-ins use the <code>AAX_RESTRICT</code> keyword, which is a cross-platform macro for the C99 standard restrict.</div><div class="section"><dl class="section note"><dt>Note</dt><dd>Now that MSVC has added C99 support to its compiler, <code>AAX_RESTRICT</code> will eventually be deprecated in favor of the <code class="Italic">restrict</code> keyword.</dd></dl>
<p>The following example demonstrates the use of restrict in our filter code.</div><div class="section"><div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">ProcessDirectFormII (</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> * <span class="keyword">const</span> AAX_RESTRICT input,</div>
<div class="line">    <span class="keywordtype">float</span> * <span class="keyword">const</span> AAX_RESTRICT output,</div>
<div class="line">    <span class="keywordtype">float</span> * <span class="keyword">const</span> AAX_RESTRICT state,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> * <span class="keyword">const</span> AAX_RESTRICT coefs ,</div>
<div class="line">    <span class="keywordtype">int</span> nsamp )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// eB0 .. eB2 and eA0, eA1 are just integer enums to partition</span></div>
<div class="line">    <span class="comment">// the filter coefficients into A and B</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// ---- LOAD ----</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefA0 = coefs [ eA0 ];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefA1 = coefs [ eA1 ];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefB0 = coefs [ eB0 ];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefB1 = coefs [ eB1 ];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> coefB2 = coefs [ eB2 ];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> state0 = state [0];</div>
<div class="line">    <span class="keywordtype">float</span> state1 = state [1];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// ---- UPDATE ----</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i =0; i&amp;lt; nsamp; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> output = input [i]* coefB0 + state0;</div>
<div class="line">        state0 = input [i]* coefB1 + state1 - output * coefA0;</div>
<div class="line">        state1 = input [i]* coefB2 - output * coefA1;</div>
<div class="line">        output [i] = output;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// ---- STORE ----</span></div>
<div class="line">    state [0] = state0;</div>
<div class="line">    state [1] = state1;</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 17: Refactored filter algorithm with load-update-store pattern and const and restrict keywords applied.</div></div><div class="section"><dl class="section note"><dt>Note</dt><dd><ul>
<li class="Bullet">
<p class="startli">This example applies <code>restrict </code>to the algorithm's input and output audio buffer pointers. These pointers do not alias each other in most algorithms, but this may not be the case for all algorithms and should be verified by the developer before applying <code>restrict</code>. </p>
<p class="endli"></p>
</li>
<li class="Bullet">
The <code>restrict</code> keyword is somewhat redundant when used with the load-update-store pattern. This is because by asserting to the compiler that the pointers are not aliased, it should be able to partially do the load-update-store refactoring automatically. However, because some compilers have limited or no support for the <code>restrict</code> keyword, using the load-update-store pattern is still recommended.  </li>
</ul>
</dd></dl>
</div><h3><a class="anchor" id="subsubsection__keywords_to_avoid_"></a>
Keywords to avoid</h3>
<div class="section"> There are some keywords which do more harm than good, but are still being used either due to legacy code or developer superstitions. These keywords should not be used in AAX plug-ins.</div><div class="section"><ul>
<li class="Bullet">
<p class="startli"><code>register</code> </p><div class="TextInd1"> The <code>register</code> keyword is a suggestion to the compiler that a certain variable will be accessed frequently and should be stored in a register rather than a memory location. Use this keyword only when you are sure that the compiler is placing a frequently-used variable in memory when it would be advantageous to keep it in a register. Note that the <code>register</code> keyword has no effect if the CGTools optimizations are enabled. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>static</code> </p><div class="TextInd1"> In C, the <code>static</code> keyword tells the compiler to initialize the variable at compilation time and retain the value between calls. Though there are some valid situations to use the <code>static</code> keyword, its use in AAX plug-ins on all platforms is extremely limited. One of its most "popular" uses, declaring local variables inside a function as <code>static</code> in order to achieve a type of global counter, should never be used in <a class="el" href="a00288.html">AAX</a> algorithm code. If you are using <code>static</code> to make a local variable hold its variable across calls to a function, it is always preferable to either pass it in to the function as a modifiable parameter or declare it as a member variable of the method (if C++). </div> <p class="endli"></p>
</li>
</ul>
</div><div class="section"></div><h2><a class="anchor" id="subsection__data_types"></a>
Data types</h2>
<div class="section">The TI C672x+ is a 32-bit floating point DSP platform, and has a few peculiarities that you should be aware of.</div><div class="section"><ul>
<li class="Bullet">
<p class="startli">Use <code>int</code> instead of <code>long</code> </p><div class="TextInd1"> Integers of type <code>long int</code> are 40 bits wide on TI, and are very inefficient. Always use the <code>int</code> data type (or, even better, the C99-standard <code>int32_t</code>) instead. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli">Use <code>float</code> instead of <code>double</code> </p><div class="TextInd1"> Double-precision floating-point data types have a significant performance penalty on TI processors. Use <code>float</code> instead of <code>double</code> wherever possible, as long as this substitution does not affect signal integrity or cancellation. </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli">Use unsigned values when referencing memory </p><div class="TextInd1"> In general, explicitly typed pointers should always be used to reference memory. If you do have need of a generic memory representation, use an unsigned integer to avoid implicit conversion costs. </div> <p class="endli"></p>
</li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__unintended_data_type_conversions_"></a>
Unintended data type conversions</h3>
<div class="section"> When developing for the TI platform it is important to keep an eye out for unintended type conversions, and especially for implicit double-precision instructions. The following points are helpful for both program efficiency and for future maintenance of the code, since they clarify the developer's understanding of how the code should operate, e.g. by specifying that a cast is occurring, and make it obvious that steps such as data type conversions are an intentional part of the algorithm. </p><ul>
<li class="Bullet">
Explicitly declare constants as single-precision. For example, use <code>0.0f</code> instead of <code>0.0</code>. Often a compiler will be able to do this automatically at compile time, but it is better to be explicit with your intended precision.  </li>
<li class="Bullet">
If any casts are required in your code, make them explicit. For example, <code>float output = (float)doubleVar</code> as opposed to <code>float output = doubleVar</code>.  </li>
<li class="Bullet">
Use single-precision math.h functions (such as <code>fabsf()</code>) instead of the double-precision equivalents (<code>fabs()</code>).  </li>
<li class="Bullet">
Do not directly reference memory addresses using integer data types; instead, use a pointer data type. If an integer data type is required, use an unsigned 32-bit type.  </li>
</ul>
</div><div class="section">To help ensure that you are not violating these principles, always be aware of any warnings generated by the compiler. In particular, do not ignore warnings related to "implicit conversion from 'double' to 'float'" or "implicit conversion from 'double' to 'int'"; these warnings may indicate that you are declaring a double when a float would be just as good.</div><div class="section">In the final stages of optimization, examine the generated assembly code to make sure there are no unintended double-precision instructions or memory accesses.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__additional_data_type_optimizations_"></a>
Additional data type optimizations</h3>
<div class="section"> The AAX SDK includes cross-platform macros that can be used to convert two single-precision float loads to one double-precision load. The coefficient smoothing case study below includes an example use case for these macros.</div><div class="section"><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> * pTable = &amp;SmoothCoefTable[address];</div>
<div class="line"><a class="code" href="a00271.html#a7eb399409be7572c8bd589395c450cdc">AAX_ALIGNMENT_HINT</a>(pTable,8);</div>
<div class="line"><span class="keywordtype">float</span> firstCoef  = <a class="code" href="a00271.html#a30b9af679d91539e6aa0871d36c4b024">AAX_LO</a>(*pTable);</div>
<div class="line"><span class="keywordtype">float</span> secondCoef = <a class="code" href="a00271.html#a51ea059e820f6ca326531adb132183c3">AAX_HI</a>(*pTable);</div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 18: Example of using AAX macros for converting two <code>float</code> loads to one <code>double</code> load.</div></div><div class="section">In this example the <a class="el" href="a00271.html#a7eb399409be7572c8bd589395c450cdc">AAX_ALIGNMENT_HINT</a> macro checks whether data is aligned on a 8-byte boundary, then the double word is loaded, and finally the <a class="el" href="a00271.html#a30b9af679d91539e6aa0871d36c4b024">AAX_LO</a> and <a class="el" href="a00271.html#a51ea059e820f6ca326531adb132183c3">AAX_HI</a> macros get the double word's first and second (<code>float</code>) parts.</div><div class="section">If <code>SmoothCoefTable</code> consists of floats and is 8-byte aligned, then this scenario will work fine for loads when <code>address</code> is even. This raises the question about how to load double word from <code>&amp;SmoothCoefTable[address]</code>, when <code>address</code> is odd. Since this kind of optimization is most useful for loading data from external memory, where the CPU savings of a single double word load vs two 32-bit loads is greatest, then one trick which can help is to trade off memory (as external memory is plentiful) for performance. Specifically, <code>SmoothCoefTable</code> can be orginized in a such way that for every member of this table, except the first and the last ones, there will be two consequent entries.</div><div class="section"><div class="fragment"><div class="line"><span class="keyword">const</span> int32_t size = 4;</div>
<div class="line"><span class="comment">// instead of this classic variant...</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> SmoothCoefTable[size] = {</div>
<div class="line">    -0.1, -0.2, -0.3, -0.4</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...table can be organized this way</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> SmoothCoefTable[size*2 - 2] = {</div>
<div class="line">    -0.1, -0.2, </div>
<div class="line">    -0.2, -0.3,</div>
<div class="line">    -0.3, -0.4,</div>
<div class="line">    -0.4,  0.0 <span class="comment">/* last member is dummy */</span></div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 19: Example of restructuring the table so that it can be easily used in the optimization scenario given above.</div></div><div class="section">In this case the number of loads will be halved at the cost of doubling the size of the table. If the table is located in external memory then the additional memory requirement can be an excellent trade-off for the performance gained.</div><div class="section"></div><h2><a class="anchor" id="subsection__case_study_efficient_parameter_smoothing_at_single_and_double_precision"></a>
Case study: Efficient parameter smoothing at single and double precision</h2>
<div class="section"> Coefficient smoothing ("de-zippering") can often be one of the most difficult parts of a plug-in to optimize for real-time operation. This is especially true in cases when full double-precision smoothing filters have been used in a plug-in's Native code, with the possibility of very small coefficients. In these cases it can be difficult to optimize the smoothing code while also satisfying requirements for audio data parity between the plug-in's Native and DSP configurations.</div><div class="section">&#160;</div><div class="section"><div class="fragment"><div class="line"><span class="keywordtype">double</span> * <span class="keyword">const</span> AAX_RESTRICT deZipper = dzCoefsP-&gt;mDeZip [ch ][0];</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> * AAX_RESTRICT coefs = myCoefsP-&gt;mBiqCoefsBuf [0];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Double - precision</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; eNumBiquads * eNumCoefs ; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> dz = deZipper [i];</div>
<div class="line">    dz += zeroCoef * ( coefs [i] - deZipper [i]);</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 20: Example of double-precision smoothing.</div></div><div class="section">In this section we will describe three specific approaches that may be taken to perform optimized real-time smoothing without compromising sound quality.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__method_1_clamped_singleprecision_smoothing_"></a>
Method 1: Clamped single-precision smoothing</h3>
<div class="section"> The simplest approach for optimization of a double-precision smoothing filter is to replace it with modified single-precision smoothing. Unfortunately, we have found that this approach can lead to glitches and instability at higher sample rates when adjusting controls due to transient innacuraccies in the smoothing.</div><div class="section"><div class="fragment"><div class="line"><span class="keywordtype">double</span> * <span class="keyword">const</span> AAX_RESTRICT deZipper = dzCoefsP-&gt;mDeZip [ch ][0];</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> * AAX_RESTRICT coefs = myCoefsP-&gt;mBiqCoefsBuf [0];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Method 1 - single - precision</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; eNumBiquads * eNumCoefs ; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> dz = deZipper [i];</div>
<div class="line">    dz += zeroCoef * ( coefs [i] - deZipper [i]);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If the de -zip step is so small that the coefficient doesn&#39;t change then clamp</span></div>
<div class="line">    <span class="comment">// the value to the target to ensure we are using exactly the desired value .</span></div>
<div class="line">    deZipper [i] = (dz == deZipper [i]) ? coefs [i] : dz;</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 21: Example of clamped single-precision smoothing.</div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__method_2_mixedprecision_smoothing_"></a>
Method 2: Mixed-precision smoothing</h3>
<div class="section"> To resolve the stability issues at high sample rates, the state may be accumulated at double-precision. This results in mixed-precision operations that are much faster on TI DSPs than full double-precision calculations, though still slower than single-precision.</div><div class="section"><div class="fragment"><div class="line"><span class="keywordtype">float</span> * <span class="keyword">const</span> AAX_RESTRICT deZipper = dzCoefsP-&gt;mDeZip [ch ][0];</div>
<div class="line"><span class="keywordtype">double</span> * <span class="keyword">const</span> AAX_RESTRICT deZipState = dzCoefsP-&gt;mDZState [ch][0];</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> * AAX_RESTRICT coefs = myCoefsP-&gt;mBiqCoefsBuf [0];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Method 2 - partial double precision</span></div>
<div class="line"><span class="preprocessor"># pragma UNROLL ( CBiquad::eNumCoefs )</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; eNumBiquads * eNumCoefs ; i ++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> dz = deZipState [i];</div>
<div class="line">    dz += zeroCoef * ((coefs [i]) - ( deZipper [i]));</div>
<div class="line">    deZipState [i] = dz;</div>
<div class="line">    deZipper [i] = float (dz);</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 22: Example of mixed-precision smoothing.</div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__method_3_loop_unrolling_and_doubleword_memory_accesses_"></a>
Method 3: Loop unrolling and double-word memory accesses</h3>
<div class="section"> Further performance gains can be made by unrolling the loop and using double word memory accesses. This code is faster, but is still not as fast as full single-precision.</div><div class="section"><div class="fragment"><div class="line"><span class="keywordtype">float</span> * <span class="keyword">const</span> AAX_RESTRICT deZipper = dzCoefsP-&gt;mDeZip [ch][0];</div>
<div class="line"><span class="keywordtype">double</span> * <span class="keyword">const</span> AAX_RESTRICT deZipState = dzCoefsP-&gt;mDZState [ch][0];</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> * AAX_RESTRICT coefs = myCoefsP-&gt;mBiqCoefsBuf [0];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Method 3 - partial double precision - unrolled with double-precision memory accesses for(int i = 0; i &lt; (eNumBiquads * eNumCoefs); i +=2 )</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> dz0 = deZipState [i];</div>
<div class="line">    <span class="keywordtype">double</span> dz1 = deZipState [i+1];</div>
<div class="line">    dz0 += zeroCoef * (<a class="code" href="a00271.html#a30b9af679d91539e6aa0871d36c4b024">AAX_LO</a> ( coefs [i]) - <a class="code" href="a00271.html#a30b9af679d91539e6aa0871d36c4b024">AAX_LO</a> ( deZipper [i]));</div>
<div class="line">    dz1 += zeroCoef * ( <a class="code" href="a00271.html#a51ea059e820f6ca326531adb132183c3">AAX_HI</a> ( coefs [i]) - <a class="code" href="a00271.html#a51ea059e820f6ca326531adb132183c3">AAX_HI</a> ( deZipper [i]));</div>
<div class="line">    deZipState [i] = dz0;</div>
<div class="line">    deZipper [i] = float (dz0);</div>
<div class="line">    deZipState [i+1] = dz1;</div>
<div class="line">    deZipper [i+1] = float (dz1);</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 23: Example of loop unrolling and double-precision memory accesses for smoothing optimization.</div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__coefficient_smoothing_example_summary_"></a>
Coefficient smoothing example summary</h3>
<div class="section"> <ul>
<li class="Bullet">
Full single-precision smoothing (method 1) is an excellent and simple solution for gain coefficients and other scalar values which are not extremely sensitive to coefficient quantization at small values. This method does not always reach the target value, so clamping should be used to ensure signal integrity.  </li>
<li class="Bullet">
Mixed-precision smoothing (method 2) uses slightly more CPU, but gives full double precision accuracy. This approach should generally be used for EQs and other sensitive coefficients.  </li>
<li class="Bullet">
Further low-level optimizations are also possible via manual loop unrolling and double-precision memory access (method 3).  </li>
</ul>
</div><div class="section"></div><h2><a class="anchor" id="subsection__refactoring_conditionals_and_branches"></a>
Refactoring conditionals and branches</h2>
<div class="section"> <dl class="section note"><dt>Note</dt><dd>For more detailed information on how to reduce or eliminate the use of branches in algorithms, see section 5.2 of the <b>Hand-Tuning Loops and Control Code on the TMS320C6000</b> guide provided by TI.</dd></dl>
<p>An important technique in refactoring algorithms to enhance loop performance is to reduce or eliminate conditionals and branches in code. The TI compiler focuses a lot of its optimization energy on keeping its pipeline full of inside loops. However, it cannot pipeline a loop if the one of the following is true:</div><div class="section"><ul>
<li class="Bullet">
The loop contains a branch  </li>
<li class="Bullet">
The loop contains a function call  </li>
<li class="Bullet">
The loop is too long  </li>
</ul>
</div><div class="section">To demonstrate this, we will again begin with an unoptimized example:</div><div class="section"><div class="fragment"><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &amp;lt; numSamples ; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (! bypass )</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> filtOutput1 = input [i] * coef0 + state0 * coef1 ;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> filtOutput2 = filtOutput1 * coef2 + state1 * coef3 ;</div>
<div class="line">        output [i] = filtOutput2 ;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        output [i] = input [i];</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 24: Another unoptimized filter algorithm.</div></div><div class="section">Though trivial, this example illustrates the problem with conditionals inside of loops. In TI assembly, conditional code usually translates into code branches, which prevents loops from pipelining effectively see <a class="el" href="a00362.html#subsection__understanding_cgtoolsgenerated_asm_files">Understanding CGTools-generated ASM files</a>. Let's refactor the loop in our example to reduce the size of its conditional branch:</div><div class="section"><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &amp;lt; numSamples ; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> filtOutput1 = input [i] * coef0 + state0 * coef1 ;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> filtOutput2 = filtOutput1 * coef2 + state1 * coef3 ;</div>
<div class="line">    output [i] = filtOutput2 ;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( bypass )</div>
<div class="line">    {</div>
<div class="line">        output [i] = input [i];</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 25: Filter algorithm with a refactored conditional branch.</div></div><div class="section">At first, it may seem wasteful to perform the filter calculation if <code>bypass</code> will simply throw away the result. In reality, however, the opposite is true: as a real-time algorithm, this code is constrained by its maximum, worst-case cycle count. It is important to understand this point: essentially, the cycle count of the plug-in is always its worst-case performance.</div><div class="section">By reducing the algorithm's maximum cycle count we are therefore reducing waste, even though we are increasing the plug-in's cycle count when it is bypassed. In fact, the ideal scenario for most algorithms is to use only one code path (and, consequentially, a single deterministic cycle count) despite the fact that this can result in worse performance for some specific states. To state this fundamental principle in a different way:</div><div class="section"><div class="TextInd1"> <em>The performance of specific states in an AAX DSP algorithm is not relevant if there is another possible state with worse performance.</em> </div></div><div class="section">Going back to our optimized example, you may also notice that the conditional still exists. Doesn't this create a branch in the assembly code as well and prevent pipelining?</div><div class="section">In the case of very brief conditionals such as this, the answer is usually no. On TI processors, most instructions can be executed conditionally, depending on the value of a control register. Thus, the single assignment <code>(output = input)</code> inside this conditional will reduce to a few conditional instructions without having to execute a branch. As a result, the TI compiler will be able to efficiently pipeline this loop.</div><div class="section">That said, it is occasionally necessary to eliminate conditionals entirely. One effective solution for these situations is to execute the branched logic algorithmically rather than conditionally. To demonstrate this approach, here is our filter example again, this time with the the conditional completely eliminated from the loop:</div><div class="section"><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &amp;lt; numSamples ; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> filtOutput1 = input [i] * coef0 + state0 * coef1 ;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> filtOutput2 = filtOutput1 * coef2 + state1 * coef3 ;</div>
<div class="line">    output [i] = (! bypass ) * filtOutput2 + bypass * input [i];</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 26: Filter algorithm with branching logic executed algorithmically.</div></div><div class="section">This code is shorter and completely eliminates the conditional from inside the loop body. However, there is an associated cost in readability, in that it is not initially obvious how exactly <code>bypass</code> affects the output. This is of course a tradeoff that you will need to consider on a case-by-case basis. In general, we encourage you to consider this technique only when you have verified in the assembly code that simply reducing the size of the conditional is not enough to achieve effective instruction pipelining.</div><div class="section">Another useful technique for optimizing loops is to use <code>pragma MUST_ITERATE</code> and <code>pragma PROB_ITERATE</code> (see more about these pragmas in <a class="el" href="a00362.html#subsubsection__loop_controls_">Loop controls</a>), which help the compiler guess the number of iterations for the loop. It is extremely useful when you know the exact number of the iterations, and this number never changes during plug-in processing. For example, this is applicable for the loops which iterate through the audio samples in the input and output buffers. The number of input samples is always constant for an AAX DSP plug-in algorithm; the buffer length must be described with the option <a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea09fbd1cbcae0e86ad81005258dc1b67e">AAX_eProperty_DSP_AudioBufferLength</a> for each DSP component in the plug-in's description.</div><div class="section">The following code example shows an algorithm processing function template. For convenience, this function template takes the audio buffer length as a template parameter:</div><div class="section"><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> kAudioWindowSize&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="a00149.html#aaa22112139aa627574b1ef562f579d43">AAX_CALLBACK</a></div>
<div class="line">Example_AlgorithmProcessFunction( SExample_Alg_Context * <span class="keyword">const</span> inInstancesBegin [], <span class="keyword">const</span> <span class="keywordtype">void</span> * inInstancesEnd)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">for</span> (SExample_Alg_Context * <span class="keyword">const</span> * walk = inInstancesBegin; walk != inInstancesEnd; ++walk)</div>
<div class="line">   {</div>
<div class="line">      SExample_Alg_Context* <span class="keyword">const</span> AAX_RESTRICT contextP = *walk;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">float</span> * <span class="keyword">const</span> AAX_RESTRICT inputP = contextP-&gt;mInputPP;</div>
<div class="line">      <span class="keywordtype">float</span> * <span class="keyword">const</span> AAX_RESTRICT outputP = contextP-&gt;mOutputPP;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">      #pragma MUST_ITERATE( kAudioWindowSize, kAudioWindowSize, kAudioWindowSize )</span></div>
<div class="line">      <span class="keywordflow">for</span> (int32_t i = 0; i &lt; kAudioWindowSize; ++i)</div>
<div class="line">      {</div>
<div class="line">         outputP[i] = inputP[i];</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 27: Optimizing loop using pragma MUST_ITERATE.</div></div><div class="section">Note that the audio buffer length property takes a <a class="el" href="a00206.html#ab33e0f1ecf04ca4161fa8d8de5845d67">AAX_EAudioBufferLengthDSP</a> value. The values of this enum are set to the power-of-two for each buffer length, so in this case the <code>kAudioWindowSize</code> value would be set to match <code>2 &lt;&lt; AAX_eProperty_DSP_AudioBufferLength</code> when compiling this algorithm callback into the TI DLL</div><div class="section">The same optimization can be used for the loops that iterate through input/output channels, as demonstrated by the DemoDist example plug-in.</div><div class="section"></div><h2><a class="anchor" id="subsection__case_study_pipeline_refactoring_in_avids_eq3_and_dyn3_plugins"></a>
Case study: pipeline refactoring in Avid's EQ3 and Dyn3 plug-ins</h2>
<div class="section"> While optimizing the "stock" Pro Tools equalization and dynamics processors we came across many real-world optimization scenarios that will be applicable to a broad variety of plug-ins. In this section we will consider specific techniques that we used to enable software pipelining of these algorithms by the TI compiler, including an in-depth look at the pseudo-speculative execution approach used in our Dyn3 plug-in's polynomial gain calculation loop.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__move_individual_processing_operations_into_separate_loops_"></a>
Move individual processing operations into separate loops</h3>
<div class="section"> Oftentimes a sample-by-sample iterative loop that is not software pipelining can be broken up into individual loops that incrementally apply changes to the audio buffer. These smaller loops have a much better chance of being successfully pipelined by the compiler. In EQ3, moving our biquad audio processing stages to dedicated loops that do not include coefficient smoothing or other tasks resulted in large performance gains.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__avoid_pipeline_dependencies_"></a>
Avoid pipeline dependencies</h3>
<div class="section"> The goal of the above optimization is to allow the compiler to successfully pipeline each iterative loop. However, even a pipelined loop may be optimized further. One of the best ways of optimizing loops is to keep the processor busy while pipeline dependencies are cleared.</div><div class="section">For example, in EQ3 we found that it was better to perform the plug-in's input and output meter calculations in the same loop rather than separating them out into individual loops. This is because each meter calculation has a dependency on its previous value, which puts a dependency in the pipeline. Doing both at the same time gives the process more to do while waiting for the next value. In Dyn3 we had similar results merging table lookup, attack, and release loops into a single iterative loop. As long as the loop is still successfully pipelined by the compiler, these "larger" loops tended to have much better performance due to the reduction in blocking dependencies.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__detailed_example_of_loop_optimization_in_dyn3_"></a>
Detailed example of loop optimization in Dyn3</h3>
<div class="section"> At this point it will be helpful to go into greater detail about our optimizations for Dyn3's polynomial gain calculation loop, because the increase in performance was quite large and is fairly representative of other algorithms. The unoptimized code took 43 cycles to execute one iteration of the loop. After rearranging the code it now takes 6 cycles. The basic problem was numerous pipeline dependencies: the <em class="Italic"> Loop Carried Dependency Bound</em> was 42 cycles, yet the <em class="Italic"> Partitioned Resource Bound</em> was 4 cycles. In other words, if all of these dependencies were removed the loop could potentially execute in 4 cycles.</div><div class="section"><div class="fragment"><div class="line">2760 ;* SOFTWARE PIPELINE INFORMATION</div>
<div class="line">2761 ;*</div>
<div class="line">2762 ;* Loop source line : 199</div>
<div class="line">2763 ;* Loop opening brace source line : 200</div>
<div class="line">2764 ;* Loop closing brace source line : 213</div>
<div class="line">2765 ;* Known Minimum Trip Count : 4</div>
<div class="line">2768 ;* Loop Carried Dependency Bound (^) : 42</div>
<div class="line">2769 ;* Unpartitioned Resource Bound : 4</div>
<div class="line">2770 ;* Partitioned Resource Bound (*) : 4</div>
<div class="line">2785 ;*</div>
<div class="line">2786 ;* Searching <span class="keywordflow">for</span> software pipeline schedule at ...</div>
<div class="line">2787 ;* ii = 42 Did not find schedule</div>
<div class="line">2788 ;* ii = 43 Schedule found with 1 iterations in parallel</div>
<div class="line">2789 ;* Done</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i =0; i&amp;lt; kAudioWindowSize ; i++) <span class="comment">// cSmoothingBlockSize</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> * smoothCoeffs = stateP -&amp;gt; mSmoothedPoly ;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> logEnv = logEnvArray [i]; <span class="comment">// logEnvArray [ fIdx +i];</span></div>
<div class="line">    logEnv -= smoothThrLow ;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>( logEnv &amp;gt;= 0.0 f) <span class="comment">// In the knee</span></div>
<div class="line">        smoothCoeffs += eCpdPolyOrder ;</div>
<div class="line">    <span class="keywordflow">if</span>( logEnv &amp;gt;= 0.0 f) <span class="comment">// In the knee</span></div>
<div class="line">        logEnv -= smoothThrLowDelta ;</div>
<div class="line">    <span class="keywordflow">if</span>( logEnv &amp;gt;= 0.0 f) <span class="comment">// In the linear GR stage</span></div>
<div class="line">        smoothCoeffs += eCpdPolyOrder ;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> filteredLogEnv = smoothCoeffs [ eCpdPolyCoeffsC ] +</div>
<div class="line">        logEnv *( smoothCoeffs [ eCpdPolyCoeffsB ] +</div>
<div class="line">        smoothCoeffs [ eCpdPolyCoeffsA ]* logEnv );</div>
<div class="line">    filtLogEnvArray [i] = filteredLogEnv + smoothedMakeupGain ;</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 28: Dyn3's unoptimized polynomial gain calculation loop and asm listing.</div></div><div class="section"><ul>
<li class="Bullet">
<p class="startli"><code>logEnv -= smoothThrLow </code> </p><div class="TextInd1"> <em class="Italic"> depends on the result of <code>logEnvArray[i]</code></em> <code></code> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>if(logEnv &gt;= 0.0f) </code> </p><div class="TextInd1"> <em class="Italic"> depends on the result of <code>logEnv -= smoothThrLow</code></em> <code></code> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>logEnv -= smoothThrLowDelta </code> </p><div class="TextInd1"> <em class="Italic"> depends on the result of <code>logEnv -= smoothThrLow</code></em> <code></code> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>Thrid if(logEnv &gt;= 0.0f) </code> </p><div class="TextInd1"> <em class="Italic"> depends on the result of <code>logEnv -= smoothThrLowDelta</code></em> <code></code> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>Second smoothCoeffs += eCpdPolyOrder </code> </p><div class="TextInd1"> <em class="Italic"> depends on the result of the first <code>smoothCoeffs += eCpdPolyOrder</code></em> <code></code> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>logEnv*smoothCoeffs[eCpdPolyCoeffsB] </code> </p><div class="TextInd1"> <em class="Italic"> depends on the result of <code>logEnv -= smoothThrLowDelta</code></em> <code></code> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>smoothCoeffs[eCpdPolyCoeffs], etc. </code> </p><div class="TextInd1"> <em class="Italic"> depend on the result of the second <code>smoothCoeffs += eCpdPolyOrder</code></em> <code></code> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>filteredLogEnv+smoothedMakeupGain </code> </p><div class="TextInd1"> <em class="Italic"> depends on the result of <code>filteredLogEnv = smoothCoeffs[eCpdPolyCoeffsC]</code></em> </div> <p class="endli"></p>
</li>
<li class="Bullet">
<p class="startli"><code>filtLogEnvArray[i] </code> </p><div class="TextInd1"> <em class="Italic"> depends on the result of <code>filteredLogEnv + smoothedMakeupGain</code></em> </div> <p class="endli"></p>
</li>
</ul>
</div><div class="section">And I don't think that even covers every case, but you get the idea. The bottom line is there is no way this loop can pipeline well. In contrast, here is the optimized code and listing file output once these dependencies have been removed:</div><div class="section"><div class="fragment"><div class="line">2476 ;* Loop opening brace source line : 167</div>
<div class="line">2477 ;* Loop closing brace source line : 179</div>
<div class="line">2446 ;* Known Minimum Trip Count : 4</div>
<div class="line">2482 ;* Loop Carried Dependency Bound (^) : 1</div>
<div class="line">2483 ;* Unpartitioned Resource Bound : 4</div>
<div class="line">2484 ;* Partitioned Resource Bound (*) : 4</div>
<div class="line">2512 ;* ii = 6 Schedule found with 5 iterations in parallel</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i =0; i&amp;lt; cProcessingBlockSize ; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> logEnv = logEnvArray [i];</div>
<div class="line">    <span class="keywordtype">float</span> logEnvThrHi = logEnv - smoothThrHigh ;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> gainSlope = smoothThrSlope +</div>
<div class="line">        logEnv * smoothSlope ;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> gainKnee = smoothKneeC +</div>
<div class="line">        logEnvThrHi *( smoothKneeB +</div>
<div class="line">        smoothKneeA * logEnvThrHi );</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> bKnee = ( logEnv &amp;gt; smoothThrLow );</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> bSlope = ( logEnv &amp;gt; smoothThrHigh );</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> filteredLogEnv = bKnee ? gainKnee : 0.0f;</div>
<div class="line">    filteredLogEnv = bSlope ? gainSlope : filteredLogEnv ;</div>
<div class="line">    filtLogEnvArray [i] = filteredLogEnv ;</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 29: Dyn3's optimized polynomial gain calculation loop and asm listing</div></div><div class="section">In this case <code>gainSlope</code> is only dependent on the loading of <code>logEnv</code>, so that can begin almost immediately. <code>GainKnee</code> must wait for <code>logEnvThrHi</code>, but <code>gainSlope</code> can be calculated during that time. <code>bKnee</code> and <code>bSlope</code> are also only dependent on <code>logEnv</code>, and start right away. The main dependency is <code>filteredLogEnv</code> which is dependent on <code>bKnee</code> and <code>gainKnee</code> and then <code>bSlope</code> and <code>gainSlope</code>. Anyhow, this is far fewer dependencies. Here is another version which runs in exactly the same number of cycles. (In fact, under the hood it may be creating the same asm code; we have not compared instruction-by-instruction.)</div><div class="section"><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i =0; i&amp;lt; kAudioWindowSize ; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> logEnv = logEnvArray [i];</div>
<div class="line">    <span class="keywordtype">float</span> logEnvThrHi = logEnv - smoothThrHigh ;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> bKnee = ( logEnv &amp;gt; thrLow );</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> bSlope = ( logEnv &amp;gt; thrHigh );</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> filteredLogEnv = bKnee ?</div>
<div class="line">        kneeC + logEnvThrHi *( kneeB + kneeA * logEnvThrHi ) :</div>
<div class="line">        0.0 f;</div>
<div class="line">    filteredLogEnv = bSlope ?</div>
<div class="line">        thrSlope + logEnv * slope :</div>
<div class="line">        filteredLogEnv ;</div>
<div class="line">    filtLogEnvArray [i] = filteredLogEnv ;</div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 30: An alternative optimization for Dyn3's polynomial gain calculation loop.</div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__but_what_about_native__"></a>
But what about Native?</h3>
<div class="section"> You might expect this altered code to execute well on a TI DSP but poorly on x86. However, keep in mind that a large degree of speculative execution is used on Intel's processors. This means that pipeline dependencies due to conditionals can be broken because multiple paths are executed. In these cases, only one of the results is used and the others are thrown away. In other words, if you saw pseudo code showing the literal execution of the unoptimized code above on Intel then it would probably look a lot like the optimized code. The lesson? For TI it is important to rearrange your code so that essentially it implements speculative execution as much as possible, and if applied correctly this optimization should not negatively impact your plug-in's native performance.</div><div class="section"></div><h2><a class="anchor" id="subsection__case_study_additional_optimization_lessons_from_eq3_and_dyn3"></a>
Case study: Additional optimization lessons from EQ3 and Dyn3</h2>
<div class="section"> The pipeline optimization example above is just one example, and the following techniques also helped us achieve many-fold increases in performance. Note that many of these techniques are discussed in greater detail in the sections above.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__watch_the_assembly_listing_"></a>
Watch the assembly listing</h3>
<div class="section"> In the process of optimizing these plug-ins we found their asm listing files very helpful, especially the <em class="Italic"> Loop Carried Dependency Bound</em> and the <em class="Italic"> Partitioned Resource Bound</em> information. The listing file shows how many cycles the code is taking to execute, and we could make an estimate of how far away we were from the optimal implementation by seeing how well the pipeline is being utilized.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__divide_processing_tasks_over_multiple_calls_"></a>
Divide processing tasks over multiple calls</h3>
<div class="section"> In the old RTAS version of EQ3 the coefficients were updated (smoothed) every 8 samples. Initially, this was changed to every 4 samples in the AAX version in order to easily work with 4-sample blocks on HDX. However, we were able to achieve better results by adding "ping pong" logic that alternates between smoothing the first and second half of the coefficients on each pass. To make this work in our odd-banded EQ we had to pad the smoothing coefficients by one biquad's worth to make an even number of biquads, but regardless of this inefficiency we still achieved performance gains.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__eliminate_branches_that_block_pipelining_"></a>
Eliminate branches that block pipelining</h3>
<div class="section"> Eliminating large conditional branches is critical to optimal performance on TI. This can be an especially tempting pitfall for developers who are used to coding only for x86 processors.</div><div class="section">Consider the "ping pong" optimization described above. This logic does not break pipelining because the conditional logic that checks the state of the flag does not result in a large branch; once the ping pong value is set, the exact same logic operates in every processing callback. If instead we used an if statement to determine which "side" should execute, this would prevent pipelining optimizations and would seriously impact performance.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__remove_doubleprecision_operations_where_they_are_not_required_"></a>
Remove double-precision operations where they are not required</h3>
<div class="section"> Here is some coefficient smoothing code from our pre-optimization EQ3 algorithm. This code was embedded in the inner biquad processing loop:</div><div class="section"><div class="fragment"><div class="line"><span class="preprocessor"># pragma UNROLL ( CBiquad::eNumCoefs )</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; CBiquad::eNumCoefs; ++k)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> &amp;dz = deZipper[k];</div>
<div class="line">    <a class="code" href="a00288.html#aaf103dc75b68b6c4f6792dd26f9b4fd0">AAX::DeDenormal</a> (dz);</div>
<div class="line">    step[k] = zeroCoef * ( coefs[k] - dz);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># pragma UNROLL ( CBiquad::eNumCoefs )</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; CBiquad::eNumCoefs; ++k)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> nm1_dz = deZipper[k]; <span class="comment">// read state</span></div>
<div class="line">    nm1_dz += step[k];</div>
<div class="line">    biquadCoefs[k] = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">float</span> <span class="keyword">&gt;</span> ( nm1_dz );</div>
<div class="line">    deZipper[k] = nm1_dz ; <span class="comment">// write state</span></div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 31: Unoptimized coefficient smoothing in EQ3</div></div><div class="section">To optimize this code, we converted the logic to use single-precision de-zipper values. However, this resulted in a sonic difference due to the fact that the smoothed coefficients would not necessarily ramp all the way to the correct target value. To solve that we added a conditional "clamp" that halts the smoothing once there is no difference between the 32-bit smoothed value and the target value. On examination of the assembler output, we found that this conditional pipelines very well.</div><div class="section"><div class="fragment"><div class="line"><span class="preprocessor"># pragma UNROLL ( CBiquad::eNumCoefs )</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; (cMaxNumBiquadsWithPad / 2) * CBiquad::eNumCoefs; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> dz = deZipper[i];</div>
<div class="line">    dz += zeroCoef * ( coefs[i] - deZipper[i]);</div>
<div class="line">    deZipper[i] = (dz == deZipper[i]) ? coefs[i] : dz; <span class="comment">// clamp</span></div>
<div class="line">} </div>
</div><!-- fragment --> <div class="fragmentcaption"> Listing 32: Optimized coefficient smoothing in EQ3</div></div><div class="section"></div><h3><a class="anchor" id="subsubsection__make_coefficients_contiguous_"></a>
Make coefficients contiguous</h3>
<div class="section"> We were able to achieve significant performance gains in iterative loops like the smoothing code shown above by ensuring that all of the coefficients that would be accessed by the loop are contiguous in memory. In addition, note that in the optimized code there is only one loop, which iterates <code>NumBiquads*NumCoefs</code> times. This optimization is possible due to the fact that each filter's coefficients are contiguous in the <code>coefs</code> array.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__use_aax_restrict_wherever_applicable_"></a>
Use AAX_RESTRICT wherever applicable</h3>
<div class="section"> We have found that the <code>restrict</code> keyword is vital for optimal performance on TI DSPs. For example, the parameter smoothing logic in our Dyn3 plug-in was reduced from 18 cycles to 3 cycles per loop iteration simply by the addition of this keyword to the applicable pointer variables.</div><div class="section">For more information about the <code>restrict</code> keyword, see <a class="el" href="a00362.html#subsubsection__restrict_">restrict</a>.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__be_aware_of_shell_overhead_"></a>
Be aware of shell overhead</h3>
<div class="section"> In the TI Shell there is code that loops through every buffered coefficient FIFO before every sample buffer in order to swap the algorithm's context field pointers to a new set of coefficients if one is available. This uses a nominal number of cycles per buffered port, which can add up very quickly in small plug-ins.</div><div class="section">For example, before our optimizations EQ3 used eight individual buffered coefficient blocks. On investigation, we found that the shell overhead from managing these buffers added up to be roughly equivalent to the algorithm's total processing cycles! To work around this we merged the 8 coefficient blocks into one large block. The trade-off of this optimization is that more work must be done on the host to re-generate and copy the whole coefficient state every time any parameter changes, so this is an optimization that should be applied only when appropriate for the individual plug-in.For example, before our optimizations EQ3 used eight individual buffered coefficient blocks. On investigation, we found that the shell overhead from managing these buffers added up to be roughly equivalent to the algorithm's total processing cycles! To work around this we merged the 8 coefficient blocks into one large block. The trade-off of this optimization is that more work must be done on the host to re-generate and copy the whole coefficient state every time any parameter changes, so this is an optimization that should be applied only when appropriate for the individual plug-in.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__watch_for_opportunities_to_merge_or_eliminate_operations_"></a>
Watch for opportunities to merge or eliminate operations</h3>
<div class="section"> Keep an eye out for unnecessary processing stages performed by your algorithm. Gain stages, phase toggles, and "dummy" coefficients are particularly good candidates for this kind of optimization. For example:</div><div class="section"><ul>
<li class="Bullet">
In our EQ3 plug-in, we found that we could achieve significant performance improvement by merging the plug-in's input and output gain stages with the overall gain of the first and last biquads. As a side benefit, this reduced the total quantization noise in the algorithm.  </li>
<li class="Bullet">
In our Dyn3 plug-in, we found that we were applying smoothing logic to filter coefficients that would always be zero.  </li>
<li class="Bullet">
When we looked more closely at Dyn3 we found that we were also computing and discarding sidechain filter information for the LFE, which is not part of the sidechain  </li>
</ul>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__read_the_ti_documentation_"></a>
Read the TI documentation</h3>
<div class="section"> There are many helpful optimization resources available from Texas Instruments. Out of all of the TI optimization documents we encountered, we found the <em class="Italic">Hand-Tuning Loops and Control Code on the TMS320C6000</em> guide to be the most helpful and complete.</div><div class="section"></div><h2><a class="anchor" id="subsection__optimization_on_the_hdx_platform"></a>
Optimization on the HDX platform</h2>
<div class="section"> </div><h3><a class="anchor" id="subsubsection__interrupt_latency_"></a>
Interrupt latency</h3>
<div class="section"> Besides the large latency due to context switching (lots of data file registers to store) and the pipeline (many stages), interrupts can be disabled around pipelined loops, which cannot be interrupted. This can be controlled with the -mi=X compiler option, which will disallow unsafe pipelining for loops that are longer than X cycles. See TI's documentation (SPRU187O Section 2.12) for more details and references regarding this behavior.</div><div class="section"></div><h3><a class="anchor" id="subsubsection__external_memory_access_"></a>
External memory access</h3>
<div class="section"> A loop which performs many reads and writes may require access to external memory. In this scenario, the loop may take 10's or even 100's of times longer to execute than the compiler expects it to!</div><div class="section">There are two options for dealing with this: </p><ol>
<li class="List">
Search and destroy these loops individually <ul>
<li class="DashInd">
Move all the data used by the loop to internal RAM.  </li>
<li class="DashInd">
Use HDX's DMA facilities for external memory accesses.  </li>
<li class="DashInd">
<code>#pragma FUNC_INTERRUPT_THRESHOLD</code> can be used to disable pipelining on a case by case basis.  </li>
</ul>
</li>
<li class="List">
For modules that are known to have these loops but are not worth hand optimizing, then turn off pipelined loop optimization altogether. (<code>-mu aka –disable_software_pipelining</code>).  </li>
</ol>
</div><div class="section"><dl class="section note"><dt>Note</dt><dd>This is only a problem in the C67(0-2)x ISAx used on the HDX platform. In The C64xx and C674x ISA, there is an SPLOOP command which can buffer the branches within pipelined loops to allow them to be interruptable.</dd></dl>
</div><h2><a class="anchor" id="subsection__code_composer_studio_optimization_tools"></a>
Code Composer Studio optimization tools</h2>
<div class="section"> </div><h3><a class="anchor" id="subsubsection__compiler_consultant_"></a>
Compiler Consultant</h3>
<div class="section"> The Compiler Consultant tool can be used to suggest additional optimizations.</div><div class="section"><em class="Infinitive"> To enable the Compiler Consultant in Code Composer Studio, do the following:</em> </p><ol>
<li class="List">
Set an optimization level of <code>-o2</code> or <code>-o3</code> (Found in CCSv4 under Build Options &gt; Compiler &gt; Basic)  </li>
<li class="List">
Set the –consultant: <code>Generate Compiler Consultant Advise</code> switch (Found in CCSv4 under Build Options &gt; Compiler &gt; Feedback)  </li>
</ol>
</div><div class="section"></div><h3><a class="anchor" id="subsubsection__optimization_information_file_"></a>
Optimization information file</h3>
<div class="section"> Optimization information files can be generated in Code Composer Studio by selecting the option Build Options &gt; Compiler &gt; Feedback &gt; Opt Info File. Optimization information files have an .nfo extension and are placed into the project's intermediate build products directory. In general, these files list function call-graph information and describe whether or not individual functions can be inlined. </div><div class="section"> </div><h1><a class="anchor" id="aax_ti_guide_07_error_codes"></a>
Error Codes</h1>
<div class="section">The following appendices document error codes that are specific to plug-in hosting in Pro Tools HDX and other AAX platforms based on the TI DSP environment.</div><div class="section"></div><h2><a class="anchor" id="subsection__138xx_dhm_core_dsp_errors"></a>
-138xx: DHM Core DSP errors</h2>
<div class="section"> These errors relate to routing and assignment problems on Pro Tools HDX hardware. Plug-ins should never be able to trigger these error codes, which indicate low-level problems in the system.</div><div class="section"><table class="doxtable">
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<td rowspan="1" colspan="2"><b>Table 1: DHM Core DSP error codes</b>   </td></tr>
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<th rowspan="1" colspan="1">Value  </th><th rowspan="1" colspan="1">Definition   </th></tr>
<tr>
<td rowspan="1" colspan="1">-13801  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_WrongSampleRate</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13802  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_NoFreeStreams</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13803  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_StreamCreationTimeout</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13804  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_StreamDestruction</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13805  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_InactiveStream</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13806  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_StreamCorrupted</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13807  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_QueueFull</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13808  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_NullPointer</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13809  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_WrongStreamID</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13810  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_ImageError</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13811  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_ResetError</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13812  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_ImageVerify</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13813  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_DSPAlreadyInBootOrReset</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13814  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_TriggerInterrupt</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13815  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_BufferSizeNotAligned</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13816  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_TimeoutWaitingForHPIC</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13817  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_SetUHPIError</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-13818  </td><td rowspan="1" colspan="1"><code>ePSError_CTIDSP_UHPINotReady</code>   </td></tr>
</table>
</div><div class="section"></div><h2><a class="anchor" id="subsection__140xx_aax_host_errors"></a>
-140xx: AAX Host errors</h2>
<div class="section"> These errors relate to logic failures in the AAX host software. These errors can be due to plug-in bugs or system configuration problems.</div><div class="section"><table class="doxtable">
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<td rowspan="1" colspan="2"><b>Table 2: AAX Host Software error codes</b>   </td></tr>
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<th rowspan="1" colspan="1">Value  </th><th rowspan="1" colspan="1">Definition   </th></tr>
<tr>
<td rowspan="1" colspan="1">-14001  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_Warning</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14003  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_UnsupportedPlatform</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14004  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_EffectNotRegistered</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14005  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_IncompleteInstantiationRequest</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14006  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_NoShellMgrLoaded</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14007  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_UnknownExceptionLoadingTIPlugIn</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14008  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_EffectComponentsMissing</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14009  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_BadLegacyPlugInIDIndex</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14010  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_EffectFactoryInitedTooManyTimes</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14011  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_InstanceNotFoundWhenDeinstantiating</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14012  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_FailedToRegisterEffectPackage</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14013  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_PlugInSignatureNotValid</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14014  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_ExceptionDuringInstantiation</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14015  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_ShuffleCancelled</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14016  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_NoPacketTargetRegistered</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14017  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_ExceptionReconnectingAfterShuffle</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14018  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_EffectModuleCreationFailed</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14019  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_AccessingUninitializedComponent</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14020  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_TIComponentInstantiationPostponed</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14021  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_FailedToRegisterEffectPackageNotAuthorized</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14022  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_FailedToRegisterEffectPackageWrongArchitecture</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14023  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_PluginBuiltAgainstIncompatibleSDKVersion</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14023  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_PluginBuiltAgainstIncompatibleSDKVersion</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14100<sup>*</sup>  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_InvalidArgumentValue</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14101<sup>*</sup>  </td><td rowspan="1" colspan="1"><code>kAAXH_Result_NameNotFoundInPageTable</code>   </td></tr>
</table>
</div><div class="section"><sup>*</sup>Overlaps with <a class="el" href="a00362.html#subsection__141xx_ti_system_errors">-141xx: TI System errors</a> definitions</div><div class="section"></div><h2><a class="anchor" id="subsection__141xx_ti_system_errors"></a>
-141xx: TI System errors</h2>
<div class="section"> These errors relate to logic failures in the TI management software and generally indicate a failure in the HDX system services such as buffered message queues, context management, and callback timing.</div><div class="section"><table class="doxtable">
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<td rowspan="1" colspan="2"><b>Table 3: TI system error codes</b>   </td></tr>
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<th rowspan="1" colspan="1">Value  </th><th rowspan="1" colspan="1">Definition   </th></tr>
<tr>
<td rowspan="1" colspan="1">-14101  </td><td rowspan="1" colspan="1"><code>eTISysErrorNotImpl</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14102  </td><td rowspan="1" colspan="1"><code>eTISysErrorMemory</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14103  </td><td rowspan="1" colspan="1"><code>eTISysErrorParam</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14104  </td><td rowspan="1" colspan="1"><code>eTISysErrorNull</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14105  </td><td rowspan="1" colspan="1"><code>eTISysErrorCommunication</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14106  </td><td rowspan="1" colspan="1"><code>eTISysErrorIllegalAccess</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14107  </td><td rowspan="1" colspan="1"><code>eTISysErrorDirectAccessOfFifoBlocksUnsupported</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14108  </td><td rowspan="1" colspan="1"><code>eTISysErrorPortIdOutOfBounds</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14109  </td><td rowspan="1" colspan="1"><code>eTISysErrorPortTypeDoesNotSupportDirectAccess</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14110  </td><td rowspan="1" colspan="1"><code>eTISysErrorFIFOFull</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14111  </td><td rowspan="1" colspan="1"><code>eTISysErrorRPCTimeOutOnDSP</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14112  </td><td rowspan="1" colspan="1"><code>eTISysErrorShellMgrChip_SegsDontMatchAddrs</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14113  </td><td rowspan="1" colspan="1"><code>eTISysErrorOnChipRPCNotRegistered</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14114  </td><td rowspan="1" colspan="1"><code>eTISysErrorUnexpectedBufferLength</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14115  </td><td rowspan="1" colspan="1"><code>eTISysErrorUnexpectedEntryPointName</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14116  </td><td rowspan="1" colspan="1"><code>eTISysErrorPortIDTooLargeForContextBlock</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14117  </td><td rowspan="1" colspan="1"><code>eTISysErrorMixerDelayNotSupportedForPlugIns</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14118  </td><td rowspan="1" colspan="1"><code>eTISysErrorShellFailedToStartUp</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14119  </td><td rowspan="1" colspan="1"><code>eTISysErrorUnexpectedCondition</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14120  </td><td rowspan="1" colspan="1"><code>eTISysErrorShellNotRunningWhenExpected</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14121  </td><td rowspan="1" colspan="1"><code>eTISysErrorFailedToCreateNewPIInstance</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14122  </td><td rowspan="1" colspan="1"><code>eTISysErrorUnknownPIInstance</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14123  </td><td rowspan="1" colspan="1"><code>eTISysErrorTooManyInstancesForSingleBufferProcessing</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14124  </td><td rowspan="1" colspan="1"><code>eTISysErrorNoDSPs</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14125  </td><td rowspan="1" colspan="1"><code>eTISysBadDSPID</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14126  </td><td rowspan="1" colspan="1"><code>eTISysBadPIContextWriteBlockSize</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14128  </td><td rowspan="1" colspan="1"><code>eTISysInstanceInitFailed</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14129  </td><td rowspan="1" colspan="1"><code>eTISysSameModuleLoadedTwiceOnSameChip</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14130  </td><td rowspan="1" colspan="1"><code>eTISysCouldNotOpenPlugInModule</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14130  </td><td rowspan="1" colspan="1"><code>eTISysCouldNotOpenPlugInModule</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14131  </td><td rowspan="1" colspan="1"><code>eTISysPlugInModuleMissingDependcies</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14132  </td><td rowspan="1" colspan="1"><code>eTISysPlugInModuleLoadableSegmentCountMismatch</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14133  </td><td rowspan="1" colspan="1"><code>eTISysPlugInModuleLoadFailure</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14134  </td><td rowspan="1" colspan="1"><code>eTISysOutOfOnChipDebuggingSpace</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14135  </td><td rowspan="1" colspan="1"><code>eTISysMissingAlgEntryPoint</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14136  </td><td rowspan="1" colspan="1"><code>eTISysInvalidRunningStatus</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14137  </td><td rowspan="1" colspan="1"><code>eTISysExceptionRunningInstantiation</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14138  </td><td rowspan="1" colspan="1"><code>eTISysTIShellBinaryNotFound</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14139  </td><td rowspan="1" colspan="1"><code>eTISysTimeoutWaitingForTIShell</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14140  </td><td rowspan="1" colspan="1"><code>eTISysSwapScriptTimeout</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14141  </td><td rowspan="1" colspan="1"><code>eTISysTIDSPModuleNotFound</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14142  </td><td rowspan="1" colspan="1"><code>eTISysTIDSPReadError</code>   </td></tr>
</table>
</div><div class="section"></div><h2><a class="anchor" id="subsection__142xx_didl_errors"></a>
-142xx: DIDL errors</h2>
<div class="section"> These errors all relate to the dynamic library loading system that manages ELF DLL binaries on Pro Tools HDX hardware. For example, a <code>eDIDL_FileNotFound</code> error will be raised if the ELF DLL name specified by an Effect's Describe code does not match any DLL that is present in the plug-in's bundle.</div><div class="section"><table class="doxtable">
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<td rowspan="1" colspan="2"><b>Table 4: DIDL error codes</b>   </td></tr>
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<th rowspan="1" colspan="1">Value  </th><th rowspan="1" colspan="1">Definition   </th></tr>
<tr>
<td rowspan="1" colspan="1">-14201  </td><td rowspan="1" colspan="1"><code>eDIDL_FileNotFound</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14202  </td><td rowspan="1" colspan="1"><code>eDIDL_FileNotOpen</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14203  </td><td rowspan="1" colspan="1"><code>eDIDL_FileAlreadyOpen</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14204  </td><td rowspan="1" colspan="1"><code>eDIDL_InvalidElfFile</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14205  </td><td rowspan="1" colspan="1"><code>eDIDL_ImageNotFound</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14206  </td><td rowspan="1" colspan="1"><code>eDIDL_SymbolNotFound</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14207  </td><td rowspan="1" colspan="1"><code>eDIDL_DependencyNotLoaded</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14208  </td><td rowspan="1" colspan="1"><code>eDIDL_BadAlignment</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14209  </td><td rowspan="1" colspan="1"><code>eDIDL_NotImplemented</code>   </td></tr>
</table>
</div><div class="section"></div><h2><a class="anchor" id="subsection__144xx_hdx_hardware_errors"></a>
-144xx: HDX hardware errors</h2>
<div class="section"> These errors relate to failures on the HDX hardware itself. Plug-ins should never be able to trigger these error codes, which indicate low-level problems in the system.</div><div class="section"><table class="doxtable">
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<td rowspan="1" colspan="2"><b>Table 5: HDX hardware error codes</b>   </td></tr>
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<th rowspan="1" colspan="1">Value  </th><th rowspan="1" colspan="1">Definition   </th></tr>
<tr>
<td rowspan="1" colspan="1">-14401  </td><td rowspan="1" colspan="1"><code>eBerlinImageError</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14402  </td><td rowspan="1" colspan="1"><code>eBerlinImageWriteError</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14403  </td><td rowspan="1" colspan="1"><code>eBerlinInvalidArgs</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14404  </td><td rowspan="1" colspan="1"><code>eBerlinCantGetTMSChannel</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14405  </td><td rowspan="1" colspan="1"><code>eBerlinChunkWriteError</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14406  </td><td rowspan="1" colspan="1"><code>eBerlinChunkReadError</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14407  </td><td rowspan="1" colspan="1"><code>eBerlinInvalidReqID</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14408  </td><td rowspan="1" colspan="1"><code>eBerlinDSPInResetError</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14409  </td><td rowspan="1" colspan="1"><code>eBerlinDSPTimeOut</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14410  </td><td rowspan="1" colspan="1"><code>eBerlinIncorrectTdmCableWiring</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14411  </td><td rowspan="1" colspan="1"><code>eBerlinInvalidClock</code>   </td></tr>
</table>
</div><div class="section"></div><h2><a class="anchor" id="subsection__145xx_dhm_isochronous_audio_engine_errors"></a>
-145xx: DHM isochronous audio engine errors</h2>
<div class="section"> These errors relate to failures within the HDX audio engine software. Plug-ins should never be able to trigger these error codes, which indicate low-level problems in the system.</div><div class="section"><table class="doxtable">
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<td rowspan="1" colspan="2"><b>Table 6: DHM isochronous audio engine error codes</b>   </td></tr>
<tr>
<td rowspan="1" colspan="2"><br />
   </td></tr>
<tr>
<th rowspan="1" colspan="1">Value  </th><th rowspan="1" colspan="1">Definition   </th></tr>
<tr>
<td rowspan="1" colspan="1">-14500  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineGenericError</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14501  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineWrongChannelNumber</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14502  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineTxRingFull</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14503  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineRxRingNotReady</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14504  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineWrongNumberOfSamplesRequest</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14505  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineUnrecognizedSampleRate</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14506  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineUnsupportedSampleSizeBytes</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14507  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineUnsupportedNumberOfChannels</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14508  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineUnsupportedSampleRate</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14509  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineDMAAlreadyEnabled</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14510  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineDMAAlreadyDisabled</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14511  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineInterruptHandlerAlreadyInstalled</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14512  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineBadCardRecord</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14513  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineCantSetValueDuringStreaming</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14514  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineStreamingAlreadyStarted</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14515  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineStreamingAlreadyStopped</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14516  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineStreamingCantBeStarted</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14517  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineUnsupportedSamplesPerInterrupt</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14518  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineCantSetSamplesPerInterrupt</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14519  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineInterruptLoopAlreadyExists</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14520  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineGlobalDMADisabled</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14521  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineActiveInterruptMaskAlreadyEnabled</code>   </td></tr>
<tr>
<td rowspan="1" colspan="1">-14522  </td><td rowspan="1" colspan="1"><code>eDsiIsochEngineSDI0Errors</code>   </td></tr>
</table>
</div><div class="section"></div><h2><a class="anchor" id="subsection__30xxx_dynamic_error_codes"></a>
-30xxx: Dynamically-generated error codes</h2>
<div class="section"> Errors in the -30xxx range are dynamically generated codes, and thus the same failure point could generate a different error code depending on the order in which errors occurred. These kinds of error codes are used heavily by the TI Shell Manager, the host component that interacts with the on–DSP shell environment.</div><div class="section">If one of these error codes is being generated by the TI Shell Manager (the most common case) then you should be able to get more information about the failure by enabling the following <a class="el" href="a00364.html">DigiTrace</a> logging facility:</div><div class="section"><div class="TextInd1"><code>DTF_TISHELLMGR=file@DTP_NORMAL</code></div></div><div class="section">or, within the DSH tool:</div><div class="section"><div class="TextInd1"><code>enable_trace_facility [DTF_TISHELLMGR, DTP_NORMAL]</code></div></div><div class="section">This should result in a log with more information such as the name of the failing plug-in, the dynamically generated error code, and a string description of its meaning. Depending on the failure case, the DAE dish command <code>getlastdsploaderror</code> can also sometimes be used to retrieve the description string for a dynamically-generated error if it was the last error generated during the DSP loading operation.</div><div class="section"></div> <div class="dynheader">
Collaboration diagram for TI Guide:</div>
<div class="dyncontent">
<center><table><tr><td><img src="a00362.png" border="0" alt="" usemap="#a00362"/>
<map name="a00362" id="a00362">
<area shape="rect" id="node1" href="a00359.html" title="Documentation for specific AAX host environments. " alt="" coords="5,5,131,32"/></map>
</td></tr></table></center>
</div>
</div><!-- contents -->
<!--        Copyright 2016, 2018 by Avid Technology, Inc.        -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<div class="FooterLegal">This product may be protected by one or more U.S. and non-U.S. patents. Details are available at <a href="https://www.avid.com/patents">www.avid.com/patents</a>.</div>
Generated on Fri Feb 2 2018 21:15:15 for AAX SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
