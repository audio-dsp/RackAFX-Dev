<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>AAX SDK: Parameter update timing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="aaxdoxy.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cw_105x65_aax_buf.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">AAX SDK
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
   <div id="projectbrief">Avid Audio Extensions Development Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Welcome</span></a></li>
      <li><a href="modules.html"><span>Manual</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Lists</span></a></li>
      <li><a href="usergroup0.html"><span>Support</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Parameter update timing<div class="ingroups"><a class="el" href="a00323.html">AAX SDK Manual</a> &raquo; <a class="el" href="a00348.html">Additional Topics</a> &raquo; <a class="el" href="a00350.html">Parameter updates</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>Details about parameter timing and how to keep parameter updates in sync. </p>
<h1><a class="anchor" id="parameterUpdateTiming_contents"></a>
On this page</h1>
<ul>
<li><a class="el" href="a00351.html#parameterUpdateTiming_timelineLocations">Timeline Locations</a> </li>
<li><a class="el" href="a00351.html#parameterUpdateTiming_synchronization">Coordinating the data model and algorithm</a> </li>
<li><a class="el" href="a00351.html#parameterUpdateTiming_sharedData">Fixing timing issues due to shared data</a> </li>
<li><a class="el" href="a00351.html#parameterUpdateTiming_timestamps">Determining the absolute timestamp for a parameter update</a></li>
</ul>
<h1><a class="anchor" id="parameterUpdateTiming_timelineLocations"></a>
Timeline Locations</h1>
<p>At any given moment, a plug-in may be asked to handle events from multiple locations on the timeline. Each module in an AAX plug-in may be updated using a different timeline position. For example: </p><ul>
<li>During automation playback the host may choose to send parameter updates in advance, while the algorithm is still processing audio from earlier in the timeline. </li>
<li>When a processing chain involves a significant amount of latency, the host may delay the metering data which is available to the plug-in's GUI until the point in time when the corresponding processed audio is actually being played back to the user.</li>
</ul>
<p>In this article, we will refer to the following timeline locations: </p><ul>
<li><em class="BoldItalic">Automation time</em>: The location that corresponds to the state of the plug-in's data model </li>
<li><em class="BoldItalic">Playhead</em>: The location where the audio engine is currently gathering samples for processing </li>
<li><em class="BoldItalic">Render time</em>: The location of the audio samples currently being processed by the plug-in's algorithm </li>
<li><em class="BoldItalic">Presentation time</em>: The location that corresponds to the playback presentation to the user (i.e. the sound coming out of the speakers)</li>
</ul>
<div class="image">
<img src="parameter_update_timing_basic_reference_times.png"  width="60%" alt="Timeline locations"/>
</div>
 <div class="imagecaption">Figure 1: Timeline locations</div><h1><a class="anchor" id="parameterUpdateTiming_synchronization"></a>
Coordinating the data model and algorithm</h1>
<p>As an AAX plug-in developer, you don't usually need to worry about the fact that your plug-in's data model and algorithm may each represent a different point in the timeline; the <a class="el" href="a00327.html#alg_comm">AAX packet system</a> handles all of the necessary synchronization between these two locations.</p>
<p>This works seamlessly in a normal AAX plug-in because the real-time algorithm is fully decoupled from the plug-in's data model. Since all of the state information for the algorithm is delivered through its <a class="el" href="a00327.html#alg_memmgmt">context structure</a>, the host can simply swap in the correct context data for each call to the processing callback. The plug-in does not require any special handling code to synchronize between the two timeline locations, and, as a bonus, AAX plug-ins can achieve deterministic, accurate automation playback without doing any extra work to handle time-stamped parameter update queues or other overhead.</p>
<div class="image">
<img src="parameter_update_timing_standard_packet_queue.png"  width="60%" alt="Synchronization through the AAX packet system"/>
</div>
 <div class="imagecaption">Figure 2: Synchronization through the AAX packet system</div><h2><a class="anchor" id="parameterUpdateTiming_packet_delivery"></a>
A closer look at the AAX packet delivery system</h2>
<dl class="section user"><dt>Adding new packets for automation events</dt><dd><p class="startdd">When playing back automation, the AAX host calls <a class="el" href="a00061.html#a685858711efb8634ce66c327f2865c71">UpdateParameterNormalizedValue()</a> to update the data model state, then calls <a class="el" href="a00061.html#a083265b008921b6114ede387711694b7">GenerateCoefficients()</a> to trigger the generation of new packets. See <a class="el" href="a00353.html">Basic parameter update sequences</a> for a full description of this sequence.</p>
<p class="enddd">Before the host calls <a class="el" href="a00061.html#a083265b008921b6114ede387711694b7">GenerateCoefficients()</a> to generate packets for an automation breakpoint, it records the timeline position of the breakpoint (<a class="el" href="a00090.html#af9ab9b228023e116f89249a56c27a20f">AAX_IController::GetCurrentAutomationTimestamp()</a> provides this value as a sample offset from the beginning of playback.) Every packet that is posted during execution of <a class="el" href="a00061.html#a083265b008921b6114ede387711694b7">GenerateCoefficients()</a> is tagged with this timestamp when it is queued for delivery. </p>
</dd></dl>
<dl class="section user"><dt>Packet delivery for AAX Native plug-ins</dt><dd><p class="startdd">As the playhead advances and sample buffers are queued for processing, the host tracks the location of the next time-stamped packet in the packet queue. As the render time location for a Native plug-in processing chain approaches the next packet time-stamp for a plug-in in the chain, the host divides the plug-in's processing buffers into smaller buffers. When the render time location is as close as possible to the packet's time-stamp, the host delivers the packet. The packet data is available to the algorithm in its context the next time it is executed.</p>
<p class="enddd">Because the host may divide native processing buffers down to a minimum size of <a class="el" href="a00206.html#aa1769ee466fd07659d8c7ef5ac61cd49a5819a4956c053084b094f686c920598e">AAX_eAudioBufferLengthNative_Min</a> - 32 samples - the host can guarantee that all automation playback will be effected within 32 samples of the actual automation breakpoint location. In addition, with the help of some extra internal bookkeeping, AAX hosts also guarantee that the exact sample where an automation breakpoint is applied will be deterministic and will not change between different playback passes. </p>
</dd></dl>
<dl class="section user"><dt>Packet delivery for AAX DSP plug-ins</dt><dd><p class="startdd">The packet delivery system for AAX DSP plug-ins works similarly to the system for AAX Native plug-ins. AAX DSP plug-ins use a fixed buffer size, so the host is not able to divide their playback buffers into smaller units: the plug-in will receive each data packet in the fixed-size playback buffer which most closely corresponds to the location of the automation event which triggered the packet.</p>
<p class="enddd">An AAX DSP plug-in which declares an <a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea09fbd1cbcae0e86ad81005258dc1b67e">AAX_eProperty_DSP_AudioBufferLength</a> value of N will be guaranteed to receive data packets within N/2 samples of the actual automation event position on the timeline. Since the default buffer size for an AAX DSP plug-in is 4 samples, this yields extremely accurate automation playback with no extra work required in the plug-in algorithm. </p>
</dd></dl>
<h1><a class="anchor" id="parameterUpdateTiming_sharedData"></a>
Fixing timing issues due to shared data</h1>
<p>The packet system works perfectly to synchronize the states of the plug-in data model and algorithm, <em class="Italic">but only when the plug-in algorithm is fully decoupled from the data model</em>. If the algorithm directly shares data with the data model then the algorithm will immediately start using any new data model state without waiting for the corresponding coefficient delivery.</p>
<p>Figure 3 shows one kind of problem that can arise when a plug-in uses the same state for both its data model and its algorithm. In this case, the plug-in applied a volume trim (shown in the automation lane at the top of the image) to its algorithm as soon as the parameter update was applied to its data model, even though the algorithm was not yet processing the audio at the Automation time location. As a result, the audio trim was applied several hundred samples too early.</p>
<div class="image">
<img src="parameter_update_timing_offset_update.png"  width="60%" alt="Offset automation playback due to lack of timeline location synchronization in a monolithic plug-in"/>
</div>
 <div class="imagecaption">Figure 3: Offset automation playback due to lack of timeline location synchronization in a monolithic plug-in</div><h2><a class="anchor" id="parameterUpdateTiming_monolithic"></a>
Monolithic plug-ins</h2>
<p>Plug-ins that share data directly between their data model and algorithm are referred to as <em class="Bold">monolithic</em>. All plug-ins that inherit from the <a class="el" href="a00026.html">AAX_CMonolithicParameters</a> helper class are monolithic.</p>
<dl class="section note"><dt>Note</dt><dd>Monolithic plug-ins must always set the <a class="el" href="a00283.html#a6571f4e41a5dd06e4067249228e2249ea79a0815fea6c8f1a0d8ed511aa88e9ff">AAX_eProperty_Constraint_Location</a> property to include <a class="el" href="a00206.html#a0c5d795c1fd021c5b9b541febc34601aa027df08c137702400a92719828bea44b">AAX_eConstraintLocationMask_DataModel</a> in order to avoid being loaded into incompatible AAX hosts.</dd></dl>
<p>All monolithic plug-ins must include special handling code to reconcile the plug-in's automation time state with its render time state.</p>
<h2><a class="anchor" id="parameterUpdateTiming_resolvingOffsets"></a>
How to resolve timing errors</h2>
<p>There are many possible solutions for the timing errors that arise when a plug-in combines data from different time locations. Ultimately, the plug-in must separate the state that is represented at different time locations.</p>
<p>In most cases, this requires deferring data model state changes from being applied to the algorithm until the relevant samples are being processed in the render callback. One easy way to accomplish this separation is to take advantage of the synchronization provided by the AAX packet delivery system. This approach benefits from the fact that it emulates the design of a normal, decoupled AAX plug-in.</p>
<p>After a packet is queued with a call to <a class="el" href="a00090.html#ae5dd2b5925dbc181513bca1c4ac5e716">PostPacket()</a>, the packet delivery system will wait to update the algorithm's context structure with the packet's data until the Render time location is very close to the automation event (see <a class="el" href="a00351.html#parameterUpdateTiming_packet_delivery">above</a>.) This provides an appropriate mechanism for deferring state changes in the plug-in's data model until the Render time location has "caught up" to the correct sample.</p>
<p>Figure 4 shows the same scenario as Figure 3, but now the plug-in has been updated to defer data model updates from the automation time location so that they are applied as coefficients in the algorithm when the render time location has reached the correct point on the timeline.</p>
<div class="image">
<img src="parameter_update_timing_monolithic_with_packet_queue.png"  width="70%" alt="Deferring a data model update in a monolithic plug-in using the packet queue"/>
</div>
 <div class="imagecaption">Figure 4: Deferring a data model update in a monolithic plug-in using the packet queue</div><p>Here is one way to use the packet delivery system to defer changes to the data model state: </p><div class="fragment"><div class="line"><a class="code" href="a00149.html#a4d8f69a697df7f70c3a8e9b8ee130d2f">AAX_Result</a></div>
<div class="line">MyEffectParameters::UpdateParameterNormalizedValue(</div>
<div class="line">  <a class="code" href="a00149.html#a1440c756fe5cb158b78193b2fc1780d1">AAX_CParamID</a> iParamID,</div>
<div class="line">  <span class="keywordtype">double</span> aValue,</div>
<div class="line">  <a class="code" href="a00206.html#a30be0398faf20c6b121239eb9399f3f7">AAX_EUpdateSource</a> inSource)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Call inherited</span></div>
<div class="line">  <a class="code" href="a00149.html#a4d8f69a697df7f70c3a8e9b8ee130d2f">AAX_Result</a> result = <a class="code" href="a00026.html#a2ebeb6e1cc24277c7e72abbbfbebb5e9">AAX_CMonolithicParameters::UpdateParameterNormalizedValue</a>(</div>
<div class="line">    iParamID,</div>
<div class="line">    aValue,</div>
<div class="line">    inSource);</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="a00207.html#a5f8c7439f3a706c4f8315a9609811937aeddbd1bb67e3a66e6af54a4b4a7a57b3">AAX_SUCCESS</a> != result) { <span class="keywordflow">return</span> result; }</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Do whatever additional work is required to note that the</span></div>
<div class="line">  <span class="comment">// parameter has been updated - for example, set a &quot;dirty&quot;</span></div>
<div class="line">  <span class="comment">// flag for the parameter.</span></div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="a00149.html#a4d8f69a697df7f70c3a8e9b8ee130d2f">AAX_Result</a></div>
<div class="line">MyEffectParameters::GenerateCoefficients()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Call inherited</span></div>
<div class="line">  <a class="code" href="a00149.html#a4d8f69a697df7f70c3a8e9b8ee130d2f">AAX_Result</a> result = <a class="code" href="a00026.html#ac9a3a7ac90562135ceb4b80301e12e92">AAX_CMonolithicParameters::GenerateCoefficients</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="a00207.html#a5f8c7439f3a706c4f8315a9609811937aeddbd1bb67e3a66e6af54a4b4a7a57b3">AAX_SUCCESS</a> != result) { <span class="keywordflow">return</span> result; }</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> uint32_t stateNum = mMyStateCounter++; <span class="comment">// member uint32_t</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Do whatever additional work is required to capture the current</span></div>
<div class="line">  <span class="comment">// parameter state and associate it with stateNum, for example</span></div>
<div class="line">  <span class="comment">// check for &quot;dirty&quot; parameters and create a list of these</span></div>
<div class="line">  <span class="comment">// parameters with their values, add this list to a map using</span></div>
<div class="line">  <span class="comment">// stateNum as a key, and clear the &quot;dirty&quot; flags.</span></div>
<div class="line">  </div>
<div class="line">  result = Controller()-&gt;PostPacket(</div>
<div class="line">    kCurrentStateFieldIndex,</div>
<div class="line">    &amp;stateNum,</div>
<div class="line">    <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line">   </div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>MyContextStructure</div>
<div class="line">{</div>
<div class="line">  int32_t * mCurrentStateNum; <span class="comment">// Private data</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">MyAudioRenderCallback(</div>
<div class="line">  MyContextStructure* <span class="keyword">const</span> inInstancesBegin [],</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">void</span>* inInstancesEnd)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">/* For each instance... */</span></div>
<div class="line">  <span class="keyword">const</span> uint32_t stateNum = instance-&gt;mCurrentStateNum;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Update the custom plug-in object state based on stateNum</span></div>
<div class="line">  <span class="comment">// and the additional data that was cached during</span></div>
<div class="line">  <span class="comment">// GenerateCoefficients().</span></div>
<div class="line">}   </div>
</div><!-- fragment --><div class="image">
<img src="parameter_update_timing_monolithic_with_packet_queue_annotated.png"  width="80%" alt="One specific solution for deferring a data model update in a monolithic plug-in using the packet queue"/>
</div>
 <div class="imagecaption">Figure 5: One specific solution for deferring a data model update in a monolithic plug-in using the packet queue</div><p>This approach is incorporated directly into the design of <a class="el" href="a00026.html">AAX_CMonolithicParameters</a>. If your plug-in data model is a subclass of <a class="el" href="a00026.html">AAX_CMonolithicParameters</a> then you can follow these steps to ensure accurate parameter update timing in your plug-in:</p>
<ol>
<li>
After creating an automatable parameter, call <a class="el" href="a00026.html#a1b23573e8aa3f8e64c61813b721559c2">AAX_CMonolithicParameters::AddSynchronizedParameter()</a> to add the parameter to an internal list of parameters to synchronize using the deferred-update system  </li>
<li>
In the plug-in's <a class="el" href="a00026.html#a04f2f73d70ea28c17747c68fc3a20fc8">RenderAudio()</a> implementation, iterate through the incoming queue of deferred parameter values  </li>
<li>
Update the coefficients used by the plug-in's algorithm or other processing components  </li>
</ol>
<p>NOTES </p><ul>
<li>
Remember to use the deferred parameter values, not values of the plug-in's <a class="el" href="a00108.html">AAX_IParameter</a> objects, when setting the state of the plug-in's coefficients  </li>
<li>
The deferred parameter values are delivered in the real-time thread, so all synchronized updates should follow the basic principles of real-time operation such as avoiding memory allocation/free, thread synchronization, access to shared resources, or any other actions which could block the real-time thread  </li>
</ul>
<p>For reference, see <a class="el" href="a00376.html#DemoMIDI_Synth">DemoMIDI_Synth</a> and the other example instrument plug-ins. All of the instrument examples in the AAX SDK use these facilities to achieve deterministic, accurate playback for automated parameters.</p>
<p>One benefit of this approach is that it provides a compatible interface with monolithic plug-in objects which are designed to work across multiple plug-in formats. For example, the set of parameter updates provided to <a class="el" href="a00026.html#a04f2f73d70ea28c17747c68fc3a20fc8">AAX_CMonolithicParameters::RenderAudio()</a> "RenderAudio" can be provided to plug-in objects which require a queue of time-stamped parameter updates for each audio render callback.</p>
<h2><a class="anchor" id="parameterUpdateTiming_considerations"></a>
Additional considerations</h2>
<p>Of course, the approach described in this section is just one possible solution. The <a class="el" href="a00351.html#parameterUpdateTiming_timestamps">timestamp</a> section below provides some alternatives to using the packet queue system for synchronization. Ultimately, the best design for your plug-in will depend on the facilities that are available in the plug-in's monolithic state object, the size of this object, its interface, the number of parameters representing its state, and other internal details.</p>
<p>Here are some additional factors to consider when using the packet queue system for time location synchronization of parameter updates: </p><ul>
<li>The algorithm callback / <a class="el" href="a00026.html#a04f2f73d70ea28c17747c68fc3a20fc8">RenderAudio()</a> method is called from a real-time thread, and may be called concurrently with data model methods. You should use a synchronization strategy that is optimized for high performance in this thread. </li>
<li>If a parameter is not automatable then you should probably ignore these additional steps and directly update the plug-in's monolithic state object from within <a class="el" href="a00061.html#a685858711efb8634ce66c327f2865c71">UpdateParameterNormalizedValue()</a> when that parameter is changed. Updates for non-automatable parameters can always be applied to the algorithm "as soon as possible". </li>
<li>Depending on your plug-in's design you may not need or want to apply this solution to some automatable parameters either. For example, parameters that are unlikely to be automated or which require CPU-intensive changes in your instrument object should probably be updated on the object directly from within <a class="el" href="a00061.html#a685858711efb8634ce66c327f2865c71">UpdateParameterNormalizedValue()</a>, and not from within the real-time thread</li>
</ul>
<h1><a class="anchor" id="parameterUpdateTiming_timestamps"></a>
Determining the absolute timestamp for a parameter update</h1>
<p>The AAX packet queue provides a host-managed system for applying parameter updates at the correct location without requiring any special knowledge about the timeline. However, In some situations a plug-in may need to know the absolute sample position of a parameter change.</p>
<p>For example, a plug-in that synchronizes parameter changes to some external system, and which wants to forward these changes over to the external system as early as possible, would want to know the sample position for a coefficient update when the update is first triggered by a call to <a class="el" href="a00061.html#a083265b008921b6114ede387711694b7">GenerateCoefficients</a>.</p>
<p>In these situations it is not suitable to simply use a method like <a class="el" href="a00116.html#a8119233b03774528ffaa519771d792a0">AAX_ITransport::GetCurrentNativeSampleLocation()</a> which returns the current position of the audio render thread. The parameter update may be occurring at a different location on the timeline from the current render position, so using the current render position for the update would result in timeline offset problems similar to those described above.</p>
<h2><a class="anchor" id="parameterUpdateTiming_timelineMethods"></a>
Obtaining timeline information</h2>
<p>AAX provides a variety of information that can be used for timeline synchronization. This information is provided through a combination of <a class="el" href="a00116.html">AAX_ITransport</a>, <a class="el" href="a00090.html">AAX_IController</a>, and MIDI beat clock data. Here is a summary of the relevant ways that a plug-in can get information about the timeline and timing synchronization data:</p>
<ul class="paragraphs">
<li>
<a class="el" href="a00116.html#a8119233b03774528ffaa519771d792a0">AAX_ITransport::GetCurrentNativeSampleLocation()</a> <div class="TextInd1"> Provides the absolute sample position of the first sample in the audio buffer that is currently being processed by the plug-in's worker chain </div>  </li>
<li>
<a class="el" href="a00090.html#afbc2973d755b6c3ae82b6c8461e9fdee">AAX_IController::GetTODLocation()</a> <div class="TextInd1"> Provides the current "time of day" value, which is a counter within the audio engine that counts the number of samples that the playhead has traversed since playback start </div>  </li>
<li>
<a class="el" href="a00090.html#af9ab9b228023e116f89249a56c27a20f">AAX_IController::GetCurrentAutomationTimestamp()</a> <div class="TextInd1"> Must be called from within <a class="el" href="a00061.html#a083265b008921b6114ede387711694b7">GenerateCoefficients</a>. Provides the timestamp for the beginning of the hardware audio buffer during which the generated coefficients will be applied to the algorithm. This timestamp is provided in terms of the "time of day" counter, i.e. the number of samples since playback started. </div>  </li>
<li>
MIDI Beat Clock <div class="TextInd1"> Sends transport start/continue/stop events to plug-ins that register global MIDI nodes </div>  </li>
</ul>
<h2><a class="anchor" id="parameterUpdateTiming_determiningTimelinePosition"></a>
Determining the timeline position of a parameter update</h2>
<p>Each of the available methods for getting information about the timeline position has a particular purpose. No single interface method can be used to directly determine the sample location for a parameter update, but it is possible to determine this value by combining information from a few of the available methods.</p>
<p>Here are some possible approaches for determining the timeline position of a parameter update</p>
<dl class="section note"><dt>Note</dt><dd>Remember that these are not strict recipes; the specific requirements for what kinds of timeline information are needed will vary from plug-in to plug-in. You may be able to refine these approach to better match the needs of your specific plug-in.</dd></dl>
<h3><a class="anchor" id="parameterUpdateTiming_determiningTimelinePosition_1"></a>
1. Defer the update to the real-time thread</h3>
<ol>
<li>
Queue state updates using a plug-in design similar to the one described <a class="el" href="a00351.html#parameterUpdateTiming_resolvingOffsets">above</a>  </li>
<li>
When a state update is received on the real-time thread, call <a class="el" href="a00116.html#a8119233b03774528ffaa519771d792a0">GetCurrentNativeSampleLocation</a> to get the sample location for the start of the current render buffer  </li>
<li>
Perform all necessary update handling using this value as the sample location  </li>
</ol>
<p>NOTES </p><ul>
<li>This approach yields a sample location value which is accurate within 32 samples </li>
<li>Event handling must be performed on the real-time render thread, which may not be viable depending on the types of operations that the plug-in must perform </li>
<li>Event handling cannot be performed in advance to reduce overall system latency</li>
</ul>
<h3><a class="anchor" id="parameterUpdateTiming_determiningTimelinePosition_2"></a>
2. Compute the timestamp as a TOD offset</h3>
<ol>
<li>
Add a queue for update events which will be used internally within the plug-in's <a class="el" href="a00099.html">AAX_IEffectParameters</a> object  </li>
<li>
In <a class="el" href="a00061.html#a685858711efb8634ce66c327f2865c71">UpdateParameterNormalizedValue</a>, enqueue an update event  </li>
<li>
In <a class="el" href="a00061.html#a083265b008921b6114ede387711694b7">GenerateCoefficients</a>, call <a class="el" href="a00090.html#afbc2973d755b6c3ae82b6c8461e9fdee">AAX_IController::GetTODLocation()</a> and <a class="el" href="a00090.html#af9ab9b228023e116f89249a56c27a20f">AAX_IController::GetCurrentAutomationTimestamp()</a>  </li>
<li>
Subtract the current TOD value from the automation timestamp to find the number of samples currently lie between the data model location and the render audio location on the timeline  </li>
<li>
Call <a class="el" href="a00116.html#a8119233b03774528ffaa519771d792a0">AAX_ITransport::GetCurrentNativeSampleLocation()</a> and add the resulting value to the sample offset that was determined in the last step. The sum of these two values is the approximate absolute sample location for the coefficient update.  </li>
<li>
Once this sample location has been calculated, dequeue all pending update events and handle them using the calculated timestamp  </li>
</ol>
<p>The reason that this approach yields an approximate value is that the TOD location and current playback location are both given in terms of the real-time audio workers, and these values continue to progress simultaneously with execution of methods on the automation update thread. As a result, this approach will yield an absolute timestamp that is "late" by between zero and one hardware buffer.</p>
<p>NOTES </p><ul>
<li>Using this approach it is possible to handle parameter updates in advance to reduce overall system latency </li>
<li>This approach yields a sample location value which is accurate within one hardware buffer </li>
<li>This approach uses AAX interface methods that are not supported in older AAX hosts such as Pro Tools 10</li>
</ul>
<h3><a class="anchor" id="parameterUpdateTiming_determiningTimelinePosition_3"></a>
3. Compute the timestamp with improved accuracy using MIDI Beat Clock</h3>
<p>You can refine the approach described above by using MBC events to detect the location of playback start.</p>
<ol>
<li>
Register a global MIDI node in your plug-in using <a class="el" href="a00096.html#aa7709de005e0256feb522758ccc5b582">AAX_IEffectDescriptor::AddControlMIDINode()</a> with <a class="el" href="a00206.html#a5e1dffce35d05990dbbad651702678e4a2be91828f8c1dac20ab5dff136fc1fce">AAX_eMIDINodeType_Global</a> and the appropriate event mask bitfield for MBC events  </li>
<li>
Override <a class="el" href="a00062.html#ab4ec161f64086070083c21b566354861">AAX_IEffectParameters::UpdateControlMIDINodes()</a> to receive MBC data  </li>
<li>
When an MBC Start or Continue event is received, call <a class="el" href="a00116.html#a8119233b03774528ffaa519771d792a0">AAX_ITransport::GetCurrentNativeSampleLocation()</a> to get the current render location. Cache this value. This value should represent the absolute playback start sample since audio render will not have started before the MBC event dispatch.  </li>
<li>
As in the previous solution, queue relevant update events in <a class="el" href="a00061.html#a685858711efb8634ce66c327f2865c71">UpdateParameterNormalizedValue</a>  </li>
<li>
In <a class="el" href="a00061.html#a083265b008921b6114ede387711694b7">GenerateCoefficients</a>, call <a class="el" href="a00090.html#af9ab9b228023e116f89249a56c27a20f">GetCurrentAutomationTimestamp</a> and add the resulting value to the cached playback start sample location  </li>
<li>
Dequeue all pending update events and handle them using the calculated absolute sample timestamp  </li>
</ol>
<p>NOTES </p><ul>
<li>Using this approach it is possible to handle parameter updates in advance to reduce overall system latency </li>
<li>This approach will yield timestamps within a few samples of the actual automation event location on the Pro Tools timeline </li>
<li>This approach uses AAX interface methods that are not supported in older AAX hosts such as Pro Tools 10 </li>
</ul>
<div class="dynheader">
Collaboration diagram for Parameter update timing:</div>
<div class="dyncontent">
<center><table><tr><td><img src="a00351.png" border="0" alt="" usemap="#a00351"/>
<map name="a00351" id="a00351">
<area shape="rect" id="node1" href="a00350.html" title="The anatomy of a parameter update. " alt="" coords="5,5,141,32"/></map>
</td></tr></table></center>
</div>
</div><!-- contents -->
<!--        Copyright 2016, 2018 by Avid Technology, Inc.        -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<div class="FooterLegal">This product may be protected by one or more U.S. and non-U.S. patents. Details are available at <a href="https://www.avid.com/patents">www.avid.com/patents</a>.</div>
Generated on Fri Feb 2 2018 21:14:40 for AAX SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
